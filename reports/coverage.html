
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-averroes/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">go-averroes/internal/calendar/calendar.go (61.0%)</option>
				
				<option value="file2">go-averroes/internal/calendar_event/calendar_event.go (52.7%)</option>
				
				<option value="file3">go-averroes/internal/common/config.go (0.0%)</option>
				
				<option value="file4">go-averroes/internal/common/context.go (0.0%)</option>
				
				<option value="file5">go-averroes/internal/common/db.go (0.0%)</option>
				
				<option value="file6">go-averroes/internal/common/logger.go (0.0%)</option>
				
				<option value="file7">go-averroes/internal/common/models.go (0.0%)</option>
				
				<option value="file8">go-averroes/internal/common/response.go (0.0%)</option>
				
				<option value="file9">go-averroes/internal/middleware/middleware.go (80.4%)</option>
				
				<option value="file10">go-averroes/internal/role/role.go (72.9%)</option>
				
				<option value="file11">go-averroes/internal/routes/routes.go (0.0%)</option>
				
				<option value="file12">go-averroes/internal/session/session.go (68.9%)</option>
				
				<option value="file13">go-averroes/internal/user/user.go (56.0%)</option>
				
				<option value="file14">go-averroes/internal/user_calendar/user_calendar.go (59.7%)</option>
				
				<option value="file15">go-averroes/testutils/testutils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "go-averroes/internal/common"
        "go-averroes/internal/middleware"
        "go-averroes/internal/routes"
        "log"
        "log/slog"

        "github.com/gin-gonic/gin"
        _ "github.com/go-sql-driver/mysql"
)

func main() <span class="cov0" title="0">{
        if err := common.InitLogger(slog.LevelInfo); err != nil </span><span class="cov0" title="0">{
                log.Fatalf(common.ErrLoggerInit, err)
        }</span>

        <span class="cov0" title="0">slog.Info(common.LogAppStart)
        cfg := common.LoadDBConfig()
        if err := common.InitDB(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf(common.ErrDatabaseConnection, err)
        }</span>

        <span class="cov0" title="0">router := gin.Default()
        router.Use(middleware.LoggingMiddleware())
        routes.RegisterRoutes(router)

        err := router.Run(":8080")
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package calendar internal/calendar/calendar.go
package calendar

import (
        "go-averroes/internal/common"
        "net/http"

        "log/slog"

        "github.com/gin-gonic/gin"
)

type CalendarStruct struct{}

var Calendar = CalendarStruct{}

// Get récupère un calendrier par user_id et calendar_id
func (CalendarStruct) Get(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogCalendarGet)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarGet + " - calendrier non trouvé dans le contexte")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarNotFound,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogCalendarGet + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessGetCalendar,
                Data:    calendarData,
        })</span>
}

// Add crée un nouveau calendrier pour un utilisateur
func (CalendarStruct) Add(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogCalendarAdd)
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">userID := userData.UserID

        slog.Info("Calendar.Add: Utilisateur récupéré", "user_id", userID)

        var req common.CreateCalendarRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogCalendarAdd + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData + ": " + err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info("Calendar.Add: Données reçues", "title", req.Title, "description", req.Description)

        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarAdd + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        result, err := tx.Exec(`
        INSERT INTO calendar (title, description, created_at) 
        VALUES (?, ?, NOW())
    `, req.Title, req.Description)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarAdd + " - erreur lors de la création du calendrier : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">calendarID, _ := result.LastInsertId()
        slog.Info("Calendar.Add: Calendrier créé", "calendar_id", calendarID)

        _, err = tx.Exec(`
        INSERT INTO user_calendar (user_id, calendar_id, created_at) 
        VALUES (?, ?, NOW())
    `, userID, calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarAdd + " - erreur lors de la création de la liaison user_calendar : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarLinkCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info("Calendar.Add: Liaison user_calendar créée", "user_id", userID, "calendar_id", calendarID)

        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarAdd + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogCalendarAdd + " - succès")
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessCreateCalendar,
                Data: gin.H{
                        "calendar_id": calendarID,
                        "user_id":     userID,
                },
        })</span>
}

// Update met à jour un calendrier par user_id et calendar_id
func (CalendarStruct) Update(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogCalendarUpdate)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarUpdate + " - calendrier non trouvé dans le contexte")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        var req common.UpdateCalendarRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogCalendarUpdate + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData + ": " + err.Error(),
                })
                return
        }</span>

        // Validation du titre obligatoire (non nil et non vide)
        <span class="cov8" title="1">if req.Title == nil || *req.Title == "" </span><span class="cov8" title="1">{
                slog.Error(common.LogCalendarUpdate + " - titre manquant ou vide")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        <span class="cov8" title="1">query := "UPDATE calendar SET updated_at = NOW(), title = ?"
        args := []interface{}{*req.Title}
        if req.Description != nil </span><span class="cov8" title="1">{
                query += ", description = ?"
                args = append(args, *req.Description)
        }</span>
        <span class="cov8" title="1">query += " WHERE calendar_id = ?"
        args = append(args, calendarID)

        _, err := common.DB.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarUpdate + " - erreur lors de la mise à jour du calendrier : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogCalendarUpdate + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUpdateCalendar,
        })</span>
}

// Delete supprime un calendrier par user_id et calendar_id
func (CalendarStruct) Delete(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogCalendarDelete)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - calendrier non trouvé dans le contexte")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        _, err = tx.Exec("UPDATE calendar SET deleted_at = NOW() WHERE calendar_id = ?", calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - erreur lors de la suppression du calendrier : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarDelete,
                })
                return
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec("UPDATE user_calendar SET deleted_at = NOW() WHERE calendar_id = ?", calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - erreur lors de la suppression des liaisons user_calendar : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarDeleteLink,
                })
                return
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec("UPDATE calendar_event SET deleted_at = NOW() WHERE calendar_id = ?", calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - erreur lors de la suppression des liaisons calendar_event : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarEventDeleteLink,
                })
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogCalendarDelete + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogCalendarDelete + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessDeleteCalendar,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package calendar_event internal/calendar_event/calendar_event.go
package calendar_event

import (
        "fmt"
        "go-averroes/internal/common"
        "log/slog"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
)

type CalendarEventStruct struct{}

var CalendarEvent = CalendarEventStruct{}

// Get récupère un événement par son ID
func (CalendarEventStruct) Get(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogEventGet)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, ok := common.GetCalendarFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">eventData, ok := common.GetEventFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogEventGet + " - événement non trouvé dans le contexte")
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogEventGet + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    eventData,
        })</span>
}

// Add crée un nouvel événement
func (CalendarEventStruct) Add(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogEventAdd)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        var req common.CreateEventRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogEventAdd + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData + ": " + err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">if req.Duration &lt; 1 </span><span class="cov0" title="0">{
                slog.Error(common.LogEventAdd + " - durée invalide")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidDuration,
                })
                return
        }</span>

        // La vérification d'accès est maintenant gérée par le middleware UserCanAccessCalendarMiddleware

        // Valeur par défaut pour canceled si non fournie
        <span class="cov8" title="1">canceled := false
        if req.Canceled != nil </span><span class="cov8" title="1">{
                canceled = *req.Canceled
        }</span>

        // Démarrer une transaction
        <span class="cov8" title="1">tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventAdd + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback() // Rollback par défaut, commit seulement si tout va bien

        // Insérer l'événement
        result, err := tx.Exec(`
                INSERT INTO event (title, description, start, duration, canceled, created_at) 
                VALUES (?, ?, ?, ?, ?, NOW())
        `, req.Title, req.Description, req.Start, req.Duration, canceled)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventAdd + " - erreur lors de la création de l'événement : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">eventID, _ := result.LastInsertId()

        // Créer la liaison calendar_event
        _, err = tx.Exec(`
                INSERT INTO calendar_event (calendar_id, event_id, created_at) 
                VALUES (?, ?, NOW())
        `, calendarID, eventID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventAdd + " - erreur lors de la création de la liaison calendar_event : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarEventLink,
                })
                return
        }</span>

        // Valider la transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventAdd + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogEventAdd + " - succès")
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessCreateEvent,
                Data: gin.H{
                        "event_id":    eventID,
                        "calendar_id": calendarID,
                },
        })</span>
}

// Update met à jour un événement
func (CalendarEventStruct) Update(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogEventUpdate)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, ok := common.GetCalendarFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">eventData, ok := common.GetEventFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogEventUpdate + " - événement non trouvé dans le contexte")
                return
        }</span>
        <span class="cov8" title="1">eventID := eventData.EventID

        var req common.UpdateEventRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogEventUpdate + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData + ": " + err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">if req.Duration != nil &amp;&amp; *req.Duration &lt; 1 </span><span class="cov0" title="0">{
                slog.Error(common.LogEventUpdate + " - durée invalide")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidDuration,
                })
                return
        }</span>

        // Construire la requête de mise à jour
        <span class="cov8" title="1">query := "UPDATE event SET updated_at = NOW()"
        var args []interface{}

        if req.Title != nil </span><span class="cov8" title="1">{
                query += ", title = ?"
                args = append(args, *req.Title)
        }</span>
        <span class="cov8" title="1">if req.Description != nil </span><span class="cov8" title="1">{
                query += ", description = ?"
                args = append(args, *req.Description)
        }</span>
        <span class="cov8" title="1">if req.Start != nil </span><span class="cov8" title="1">{
                query += ", start = ?"
                args = append(args, *req.Start)
        }</span>
        <span class="cov8" title="1">if req.Duration != nil </span><span class="cov8" title="1">{
                query += ", duration = ?"
                args = append(args, *req.Duration)
        }</span>
        <span class="cov8" title="1">if req.Canceled != nil </span><span class="cov8" title="1">{
                query += ", canceled = ?"
                args = append(args, *req.Canceled)
        }</span>

        <span class="cov8" title="1">query += " WHERE event_id = ?"
        args = append(args, eventID)

        _, err := common.DB.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventUpdate + " - erreur lors de la mise à jour de l'événement : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogEventUpdate + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUpdateEvent,
        })</span>
}

// Delete supprime un événement (soft delete)
func (CalendarEventStruct) Delete(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogEventDelete)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, ok := common.GetCalendarFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">eventData, ok := common.GetEventFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogEventDelete + " - événement non trouvé dans le contexte")
                return
        }</span>
        <span class="cov8" title="1">eventID := eventData.EventID

        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventDelete + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback() // Rollback par défaut, commit seulement si tout va bien

        // Soft delete de l'événement
        _, err = tx.Exec("UPDATE event SET deleted_at = NOW() WHERE event_id = ?", eventID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventDelete + " - erreur lors de la suppression de l'événement : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventDelete,
                })
                return
        }</span>

        // Soft delete des liaisons calendar_event
        <span class="cov8" title="1">_, err = tx.Exec("UPDATE calendar_event SET deleted_at = NOW() WHERE event_id = ?", eventID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventDelete + " - erreur lors de la suppression de la liaison calendar_event : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrCalendarEventDeleteLink,
                })
                return
        }</span>

        // Valider la transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventDelete + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogEventDelete + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessDeleteEvent,
        })</span>
}

// List récupère les événements d'un calendrier avec filtres temporels
func (CalendarEventStruct) List(c *gin.Context) <span class="cov0" title="0">{
        slog.Info(common.LogEventList)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">calendarID := calendarData.CalendarID

        // Récupérer les paramètres de filtrage depuis les query parameters
        filterType := c.Query("filter_type")
        dateStr := c.Query("date")

        // Validation des paramètres
        if filterType == "" || dateStr == "" </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - paramètres de filtrage manquants")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrMissingFilterParams,
                })
                return
        }</span>

        // Validation du type de filtre
        <span class="cov0" title="0">if filterType != "month" &amp;&amp; filterType != "week" &amp;&amp; filterType != "day" </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - type de filtre invalide")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidFilterType,
                })
                return
        }</span>

        // Parser la date et calculer les bornes temporelles
        <span class="cov0" title="0">startDate, endDate, err := parseDateFilter(filterType, dateStr)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - format de date invalide : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   fmt.Sprintf(common.ErrInvalidDateFormat, err.Error()),
                })
                return
        }</span>

        // Construire la requête SQL avec JOIN pour récupérer les événements du calendrier
        <span class="cov0" title="0">query := `
                SELECT e.event_id, e.title, e.description, e.start, e.duration, e.canceled, 
                       e.created_at, e.updated_at, e.deleted_at 
                FROM event e
                INNER JOIN calendar_event ce ON e.event_id = ce.event_id
                WHERE ce.calendar_id = ? AND ce.deleted_at IS NULL 
                  AND e.deleted_at IS NULL 
                  AND e.start &gt;= ? AND e.start &lt; ?
                ORDER BY e.start ASC
        `

        // Exécuter la requête
        rows, err := common.DB.Query(query, calendarID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - erreur lors de la récupération des événements : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventsRetrieval,
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []common.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var event common.Event
                err := rows.Scan(&amp;event.EventID, &amp;event.Title, &amp;event.Description, &amp;event.Start, &amp;event.Duration, &amp;event.Canceled, &amp;event.CreatedAt, &amp;event.UpdatedAt, &amp;event.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogEventList + " - erreur lors de la lecture des événements : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrEventsReading,
                        })
                        return
                }</span>
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - erreur lors de l'itération des résultats : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventsRetrieval,
                })
                return
        }</span>

        <span class="cov0" title="0">slog.Info(fmt.Sprintf("%s - succès, %d événements trouvés", common.LogEventList, len(events)))
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessListEvents,
                Data:    events,
        })</span>
}

// parseDateFilter parse la date selon le type de filtre et retourne les bornes temporelles
func parseDateFilter(filterType, dateStr string) (time.Time, time.Time, error) <span class="cov0" title="0">{
        switch filterType </span>{
        case "day":<span class="cov0" title="0">
                // Format: "2024-01-15"
                date, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, time.Time{}, fmt.Errorf(common.ErrInvalidDayFormat)
                }</span>
                <span class="cov0" title="0">startDate := date
                endDate := date.Add(24 * time.Hour)
                return startDate, endDate, nil</span>

        case "week":<span class="cov0" title="0">
                // Format: "2024-W01" (année-semaine ISO)
                parts := strings.Split(dateStr, "-W")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return time.Time{}, time.Time{}, fmt.Errorf(common.ErrInvalidWeekFormat)
                }</span>
                <span class="cov0" title="0">year, err := strconv.Atoi(parts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, time.Time{}, fmt.Errorf(common.ErrInvalidYear)
                }</span>
                <span class="cov0" title="0">week, err := strconv.Atoi(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, time.Time{}, fmt.Errorf(common.ErrInvalidWeekNumber)
                }</span>

                // Calculer le premier jour de la semaine ISO (lundi de la semaine 1)
                // La semaine 1 est celle qui contient le 4 janvier
                <span class="cov0" title="0">jan4 := time.Date(year, 1, 4, 0, 0, 0, 0, time.UTC)
                weekday := int(jan4.Weekday())
                if weekday == 0 </span><span class="cov0" title="0">{
                        weekday = 7 // Dimanche = 7
                }</span>
                // Le lundi de la semaine 1
                <span class="cov0" title="0">week1Monday := jan4.AddDate(0, 0, 1-weekday)
                // Le lundi de la semaine demandée
                startDate := week1Monday.AddDate(0, 0, (week-1)*7)
                endDate := startDate.AddDate(0, 0, 7)
                return startDate, endDate, nil</span>

        case "month":<span class="cov0" title="0">
                // Format: "2024-01"
                date, err := time.Parse("2006-01", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, time.Time{}, fmt.Errorf(common.ErrInvalidMonthFormat)
                }</span>
                <span class="cov0" title="0">startDate := date
                endDate := date.AddDate(0, 1, 0)
                return startDate, endDate, nil</span>

        default:<span class="cov0" title="0">
                return time.Time{}, time.Time{}, fmt.Errorf(common.ErrUnsupportedFilterType)</span>
        }
}

// ListByMonth récupère les événements d'un calendrier pour un mois donné
func (CalendarEventStruct) ListByMonth(c *gin.Context) <span class="cov8" title="1">{
        yearStr := c.Param("year")
        monthStr := c.Param("month")
        year, err := strconv.Atoi(yearStr)
        if err != nil || year &lt; 1 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidYear})
                return
        }</span>
        <span class="cov8" title="1">month, err := strconv.Atoi(monthStr)
        if err != nil || month &lt; 1 || month &gt; 12 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidMonth})
                return
        }</span>
        <span class="cov8" title="1">startDate := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)
        endDate := startDate.AddDate(0, 1, 0)
        listEventsWithRange(c, startDate, endDate)</span>
}

// ListByWeek récupère les événements d'un calendrier pour une semaine ISO donnée
func (CalendarEventStruct) ListByWeek(c *gin.Context) <span class="cov8" title="1">{
        yearStr := c.Param("year")
        weekStr := c.Param("week")
        year, err := strconv.Atoi(yearStr)
        if err != nil || year &lt; 1 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidYear})
                return
        }</span>
        <span class="cov8" title="1">week, err := strconv.Atoi(weekStr)
        if err != nil || week &lt; 1 || week &gt; 53 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidWeekNumber})
                return
        }</span>
        <span class="cov8" title="1">jan4 := time.Date(year, 1, 4, 0, 0, 0, 0, time.UTC)
        weekday := int(jan4.Weekday())
        if weekday == 0 </span><span class="cov0" title="0">{
                weekday = 7
        }</span>
        <span class="cov8" title="1">week1Monday := jan4.AddDate(0, 0, 1-weekday)
        startDate := week1Monday.AddDate(0, 0, (week-1)*7)
        endDate := startDate.AddDate(0, 0, 7)
        listEventsWithRange(c, startDate, endDate)</span>
}

// ListByDay récupère les événements d'un calendrier pour un jour donné
func (CalendarEventStruct) ListByDay(c *gin.Context) <span class="cov8" title="1">{
        yearStr := c.Param("year")
        monthStr := c.Param("month")
        dayStr := c.Param("day")
        year, err := strconv.Atoi(yearStr)
        if err != nil || year &lt; 1 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidYear})
                return
        }</span>
        <span class="cov8" title="1">month, err := strconv.Atoi(monthStr)
        if err != nil || month &lt; 1 || month &gt; 12 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidMonth})
                return
        }</span>
        <span class="cov8" title="1">day, err := strconv.Atoi(dayStr)
        if err != nil || day &lt; 1 || day &gt; 31 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, common.JSONResponse{Success: false, Error: common.ErrInvalidDay})
                return
        }</span>
        <span class="cov8" title="1">startDate := time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC)
        endDate := startDate.AddDate(0, 0, 1)
        listEventsWithRange(c, startDate, endDate)</span>
}

// listEventsWithRange est une fonction utilitaire pour factoriser la logique de récupération
func listEventsWithRange(c *gin.Context, startDate, endDate time.Time) <span class="cov8" title="1">{
        slog.Info(common.LogEventList)
        if _, ok := common.GetUserFromContext(c); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        query := `
                SELECT e.event_id, e.title, e.description, e.start, e.duration, e.canceled, 
                       e.created_at, e.updated_at, e.deleted_at 
                FROM event e
                INNER JOIN calendar_event ce ON e.event_id = ce.event_id
                WHERE ce.calendar_id = ? AND ce.deleted_at IS NULL 
                  AND e.deleted_at IS NULL 
                  AND e.start &gt;= ? AND e.start &lt; ?
                ORDER BY e.start ASC
        `
        rows, err := common.DB.Query(query, calendarID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - erreur lors de la récupération des événements : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventsRetrieval,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var events []common.Event
        for rows.Next() </span><span class="cov8" title="1">{
                var event common.Event
                err := rows.Scan(&amp;event.EventID, &amp;event.Title, &amp;event.Description, &amp;event.Start, &amp;event.Duration, &amp;event.Canceled, &amp;event.CreatedAt, &amp;event.UpdatedAt, &amp;event.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogEventList + " - erreur lors de la lecture des événements : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrEventsReading,
                        })
                        return
                }</span>
                <span class="cov8" title="1">events = append(events, event)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogEventList + " - erreur lors de l'itération des résultats : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrEventsRetrieval,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(fmt.Sprintf("%s - succès, %d événements trouvés", common.LogEventList, len(events)))
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessListEvents,
                Data:    events,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package common

import (
        "os"
)

type DBConfig struct {
        User     string
        Password string
        Host     string
        Port     int
        Name     string
}

// LoadDBConfig charge la configuration de la base de données depuis les variables d'environnement ou des valeurs par défaut
func LoadDBConfig() DBConfig <span class="cov0" title="0">{
        return DBConfig{
                User:     getEnv("DB_USER", "root"),
                Password: getEnv("DB_PASSWORD", "password"),
                Host:     getEnv("DB_HOST", "golendar_db"),
                Port:     3306,
                Name:     getEnv("DB_NAME", "calendar"),
        }
}</span>

// getEnv retourne la valeur d'une variable d'environnement ou une valeur par défaut si elle n'est pas définie.
func getEnv(key, defaultVal string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// GetUserFromContext récupère l'utilisateur authentifié du contexte Gin (clé 'auth_user'), ou à défaut 'user' (pour compatibilité).
func GetUserFromContext(c *gin.Context) (User, bool) <span class="cov0" title="0">{
        user, exists := c.Get("auth_user")
        if !exists </span><span class="cov0" title="0">{
                // Pour compatibilité descendante, on tente 'user'
                user, exists = c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, JSONResponse{
                                Success: false,
                                Error:   ErrInternalUserNotInContext,
                        })
                        return User{}, false
                }</span>
        }
        <span class="cov0" title="0">userData, ok := user.(User)
        if !ok </span><span class="cov0" title="0">{
                // This case should ideally not happen if middleware is set correctly
                c.JSON(http.StatusInternalServerError, JSONResponse{
                        Success: false,
                        Error:   ErrContextUserType,
                })
                return User{}, false
        }</span>
        <span class="cov0" title="0">return userData, true</span>
}

// GetCalendarFromContext récupère le calendrier du contexte Gin.
// En cas d'échec, il envoie une réponse d'erreur et retourne false.
func GetCalendarFromContext(c *gin.Context) (Calendar, bool) <span class="cov0" title="0">{
        calendar, exists := c.Get("calendar")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, JSONResponse{
                        Success: false,
                        Error:   ErrInternalCalendarNotInContext,
                })
                return Calendar{}, false
        }</span>
        <span class="cov0" title="0">calendarData, ok := calendar.(Calendar)
        if !ok </span><span class="cov0" title="0">{
                // This case should ideally not happen if middleware is set correctly
                c.JSON(http.StatusInternalServerError, JSONResponse{
                        Success: false,
                        Error:   ErrContextCalendarType,
                })
                return Calendar{}, false
        }</span>
        <span class="cov0" title="0">return calendarData, true</span>
}

// GetEventFromContext récupère l'événement du contexte Gin.
// En cas d'échec, il envoie une réponse d'erreur et retourne false.
func GetEventFromContext(c *gin.Context) (Event, bool) <span class="cov0" title="0">{
        event, exists := c.Get("event")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, JSONResponse{
                        Success: false,
                        Error:   ErrEventRetrieval,
                })
                return Event{}, false
        }</span>
        <span class="cov0" title="0">eventData, ok := event.(Event)
        if !ok </span><span class="cov0" title="0">{
                // This case should ideally not happen if middleware is set correctly
                c.JSON(http.StatusInternalServerError, JSONResponse{
                        Success: false,
                        Error:   ErrEventRetrieval,
                })
                return Event{}, false
        }</span>
        <span class="cov0" title="0">return eventData, true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package common

import (
        "database/sql"
        "fmt"
)

var DB *sql.DB

// InitDB initialise la connexion à la base de données MySQL à partir d'une DBConfig et vérifie la connexion.
func InitDB(cfg DBConfig) error <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&amp;charset=utf8mb4&amp;loc=Local", cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.Name)
        var err error
        DB, err = sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Vérifie la connexion
        <span class="cov0" title="0">return DB.Ping()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package common

import (
        "log/slog"
        "os"
)

// InitLogger initialise le logger structuré slog avec sortie fichier et format JSON.
func InitLogger(logLevel slog.Level) error <span class="cov0" title="0">{
        if _, err := os.Stat("logs"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.Mkdir("logs", 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">file, err := os.OpenFile("logs/app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">h := slog.NewJSONHandler(file, &amp;slog.HandlerOptions{Level: logLevel})
        slog.SetDefault(slog.New(h))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package common

import "time"

// User représente la table user
type User struct {
        UserID    int        `json:"user_id" db:"user_id"`
        Lastname  string     `json:"lastname" db:"lastname"`
        Firstname string     `json:"firstname" db:"firstname"`
        Email     string     `json:"email" db:"email"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserPassword représente la table user_password
type UserPassword struct {
        UserPasswordID int        `json:"user_password_id" db:"user_password_id"`
        UserID         int        `json:"user_id" db:"user_id"`
        PasswordHash   string     `json:"-" db:"password_hash"`
        ExpiredAt      *time.Time `json:"expired_at,omitempty" db:"expired_at"`
        CreatedAt      time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt      *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt      *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Calendar représente la table calendar
type Calendar struct {
        CalendarID  int        `json:"calendar_id" db:"calendar_id"`
        Title       string     `json:"title" db:"title"`
        Description *string    `json:"description,omitempty" db:"description"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt   *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Event représente la table event
type Event struct {
        EventID     int        `json:"event_id" db:"event_id"`
        Title       string     `json:"title" db:"title"`
        Description *string    `json:"description,omitempty" db:"description"`
        Start       time.Time  `json:"start" db:"start"`
        Duration    int        `json:"duration" db:"duration"`
        Canceled    bool       `json:"canceled" db:"canceled"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt   *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserCalendar représente la table user_calendar
type UserCalendar struct {
        UserCalendarID int        `json:"user_calendar_id" db:"user_calendar_id"`
        UserID         int        `json:"user_id" db:"user_id"`
        CalendarID     int        `json:"calendar_id" db:"calendar_id"`
        CreatedAt      time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt      *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt      *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// CalendarEvent représente la table calendar_event
type CalendarEvent struct {
        CalendarEventID int        `json:"calendar_event_id" db:"calendar_event_id"`
        CalendarID      int        `json:"calendar_id" db:"calendar_id"`
        EventID         int        `json:"event_id" db:"event_id"`
        CreatedAt       time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt       *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt       *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserCalendarWithDetails représente un calendrier avec ses détails pour un utilisateur
type UserCalendarWithDetails struct {
        UserCalendarID int        `json:"user_calendar_id" db:"user_calendar_id"`
        UserID         int        `json:"user_id" db:"user_id"`
        CalendarID     int        `json:"calendar_id" db:"calendar_id"`
        Title          string     `json:"title" db:"title"`
        Description    *string    `json:"description,omitempty" db:"description"`
        CreatedAt      time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt      *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt      *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Role représente la table roles
type Role struct {
        RoleID      int        `json:"role_id" db:"role_id"`
        Name        string     `json:"name" db:"name"`
        Description *string    `json:"description,omitempty" db:"description"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt   *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserRole représente la table user_roles
type UserRole struct {
        UserRolesID int        `json:"user_roles_id" db:"user_roles_id"`
        UserID      int        `json:"user_id" db:"user_id"`
        RoleID      int        `json:"role_id" db:"role_id"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt   *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserSession représente la table user_session
type UserSession struct {
        UserSessionID int        `json:"user_session_id" db:"user_session_id"`
        UserID        int        `json:"user_id" db:"user_id"`
        SessionToken  string     `json:"session_token" db:"session_token"`
        RefreshToken  *string    `json:"refresh_token,omitempty" db:"refresh_token"`
        ExpiresAt     time.Time  `json:"expires_at" db:"expires_at"`
        DeviceInfo    *string    `json:"device_info,omitempty" db:"device_info"`
        IPAddress     *string    `json:"ip_address,omitempty" db:"ip_address"`
        IsActive      bool       `json:"is_active" db:"is_active"`
        CreatedAt     time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt     *time.Time `json:"updated_at,omitempty" db:"updated_at"`
        DeletedAt     *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// UserWithRoles représente un utilisateur avec ses rôles
type UserWithRoles struct {
        User
        Roles []Role `json:"roles"`
}

// UserSessionWithUser représente une session avec les informations de l'utilisateur
type UserSessionWithUser struct {
        UserSession
        User User `json:"user"`
}

// Structures pour les requêtes
type CreateUserRequest struct {
        Lastname  string `json:"lastname" binding:"required"`
        Firstname string `json:"firstname" binding:"required"`
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=6"`
}

type UpdateUserRequest struct {
        Lastname  *string `json:"lastname,omitempty"`
        Firstname *string `json:"firstname,omitempty"`
        Email     *string `json:"email,omitempty"`
        Password  *string `json:"password,omitempty"`
}

type CreateCalendarRequest struct {
        Title       string  `json:"title" binding:"required"`
        Description *string `json:"description,omitempty"`
}

type UpdateCalendarRequest struct {
        Title       *string `json:"title,omitempty"`
        Description *string `json:"description,omitempty"`
}

type CreateEventRequest struct {
        Title       string    `json:"title" binding:"required"`
        Description *string   `json:"description,omitempty"`
        Start       time.Time `json:"start" binding:"required"`
        Duration    int       `json:"duration" binding:"required,min=1"`
        CalendarID  int       `json:"calendar_id" binding:"required"`
        Canceled    *bool     `json:"canceled,omitempty"`
}

type UpdateEventRequest struct {
        Title       *string    `json:"title,omitempty"`
        Description *string    `json:"description,omitempty"`
        Start       *time.Time `json:"start,omitempty"`
        Duration    *int       `json:"duration,omitempty" binding:"omitempty,min=1"`
        Canceled    *bool      `json:"canceled,omitempty"`
}

// Structures pour les requêtes de filtrage des événements
type ListEventsRequest struct {
        FilterType string `json:"filter_type" binding:"required,oneof=month week day"`
        Date       string `json:"date" binding:"required"` // Format: "2024-01-15" pour jour, "2024-01" pour mois, "2024-W01" pour semaine
}

// Structures pour l'authentification et les sessions
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

type LoginResponse struct {
        User         User      `json:"user"`
        SessionToken string    `json:"session_token"`
        RefreshToken string    `json:"refresh_token,omitempty"`
        ExpiresAt    time.Time `json:"expires_at"`
        Roles        []Role    `json:"roles"`
}

type CreateRoleRequest struct {
        Name        string  `json:"name" binding:"required"`
        Description *string `json:"description,omitempty"`
}

type UpdateRoleRequest struct {
        Name        *string `json:"name,omitempty"`
        Description *string `json:"description,omitempty"`
}

type AssignRoleRequest struct {
        UserID int `json:"user_id" binding:"required"`
        RoleID int `json:"role_id" binding:"required"`
}

type RevokeRoleRequest struct {
        UserID int `json:"user_id" binding:"required"`
        RoleID int `json:"role_id" binding:"required"`
}

type CreateSessionRequest struct {
        UserID     int     `json:"user_id" binding:"required"`
        DeviceInfo *string `json:"device_info,omitempty"`
        IPAddress  *string `json:"ip_address,omitempty"`
}

// StringPtr retourne un pointeur vers la chaîne passée en argument.
func StringPtr(s string) *string <span class="cov0" title="0">{ return &amp;s }</span>

// IntPtr retourne un pointeur vers l'entier passé en argument.
func IntPtr(i int) *int <span class="cov0" title="0">{ return &amp;i }</span>

// BoolPtr retourne un pointeur vers le booléen passé en argument.
func BoolPtr(b bool) *bool <span class="cov0" title="0">{ return &amp;b }</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package common

import (
        "database/sql"
        "net/http"

        "github.com/gin-gonic/gin"
)

type JSONResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message,omitempty"`
        Data    any    `json:"data,omitempty"`
        Error   string `json:"error,omitempty"`
}

// HandleDBError gère les erreurs courantes de la base de données (ErrNoRows ou autre)
// et envoie la réponse JSON appropriée. Retourne true si une erreur a été gérée.
func HandleDBError(c *gin.Context, err error, statusNotFound int, msgNotFound string, msgInternal string) bool <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(statusNotFound, JSONResponse{
                                Success: false,
                                Error:   msgNotFound,
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, JSONResponse{
                                Success: false,
                                Error:   msgInternal,
                        })
                }</span>
                <span class="cov0" title="0">c.Abort()
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "fmt"
        "go-averroes/internal/common"
        "go-averroes/internal/session"
        "net/http"
        "strconv"
        "strings"

        "log/slog"
        "time"

        "github.com/gin-gonic/gin"
)

// UserExistsMiddleware vérifie l'existence d'un utilisateur à partir d'un paramètre dans l'URL
// paramName: nom du paramètre à vérifier (ex: "id", "user_id")
func UserExistsMiddleware(paramName string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userIDStr := c.Param(paramName)
                userID, err := strconv.Atoi(userIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInvalidUserID,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">var user common.User
                err = common.DB.QueryRow(
                        "SELECT user_id, lastname, firstname, email, created_at, updated_at, deleted_at FROM user WHERE user_id = ? AND deleted_at IS NULL",
                        userID,
                ).Scan(
                        &amp;user.UserID,
                        &amp;user.Lastname,
                        &amp;user.Firstname,
                        &amp;user.Email,
                        &amp;user.CreatedAt,
                        &amp;user.UpdatedAt,
                        &amp;user.DeletedAt,
                )

                if common.HandleDBError(c, err, http.StatusNotFound, common.ErrUserNotFound, common.ErrUserVerification) </span><span class="cov8" title="1">{
                        return
                }</span>

                // L'utilisateur existe, on l'ajoute au contexte et on continue
                <span class="cov8" title="1">c.Set("user", user)
                c.Next()</span>
        }
}

func CalendarExistsMiddleware(paramName string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                calendarIDStr := c.Param(paramName)
                calendarID, err := strconv.Atoi(calendarIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("CalendarExistsMiddleware: ID de calendrier invalide", "calendar_id", calendarIDStr, "error", err.Error())
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInvalidCalendarID,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">slog.Info("CalendarExistsMiddleware: Recherche du calendrier", "calendar_id", calendarID)

                var calendar common.Calendar
                err = common.DB.QueryRow(
                        "SELECT calendar_id, title, description, created_at, updated_at, deleted_at FROM calendar WHERE calendar_id = ? AND deleted_at IS NULL",
                        calendarID,
                ).Scan(
                        &amp;calendar.CalendarID,
                        &amp;calendar.Title,
                        &amp;calendar.Description,
                        &amp;calendar.CreatedAt,
                        &amp;calendar.UpdatedAt,
                        &amp;calendar.DeletedAt,
                )

                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("CalendarExistsMiddleware: Calendrier non trouvé", "calendar_id", calendarID, "error", err.Error())
                        if common.HandleDBError(c, err, http.StatusNotFound, common.ErrCalendarNotFound, common.ErrCalendarVerification) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }

                <span class="cov8" title="1">slog.Info("CalendarExistsMiddleware: Calendrier trouvé", "calendar_id", calendar.CalendarID, "title", calendar.Title)

                // Le calendrier existe, on l'ajoute au contexte et on continue
                c.Set("calendar", calendar)
                c.Next()</span>
        }
}

func RoleExistsMiddleware(paramName string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                roleIDStr := c.Param(paramName)
                roleID, err := strconv.Atoi(roleIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInvalidData,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">var role common.Role
                err = common.DB.QueryRow(
                        "SELECT role_id, name, description, created_at, updated_at, deleted_at FROM roles WHERE role_id = ? AND deleted_at IS NULL",
                        roleID,
                ).Scan(
                        &amp;role.RoleID,
                        &amp;role.Name,
                        &amp;role.Description,
                        &amp;role.CreatedAt,
                        &amp;role.UpdatedAt,
                        &amp;role.DeletedAt,
                )

                if common.HandleDBError(c, err, http.StatusNotFound, common.ErrRoleNotFound, common.ErrRoleNotFound) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Le rôle existe, on l'ajoute au contexte et on continue
                <span class="cov0" title="0">c.Set("role", role)
                c.Next()</span>
        }
}

func UserCanAccessCalendarMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userData, ok := common.GetUserFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        slog.Error("UserCanAccessCalendarMiddleware: Utilisateur non trouvé dans le contexte")
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserNotAuthenticated,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">slog.Info("UserCanAccessCalendarMiddleware: Utilisateur trouvé", "user_id", userData.UserID, "email", userData.Email)

                calendarData, ok := common.GetCalendarFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        slog.Error("UserCanAccessCalendarMiddleware: Calendrier non trouvé dans le contexte")
                        c.JSON(http.StatusNotFound, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrCalendarNotFound,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">slog.Info("UserCanAccessCalendarMiddleware: Calendrier trouvé", "calendar_id", calendarData.CalendarID, "title", calendarData.Title)

                // Vérifier que l'utilisateur a accès au calendrier
                var accessCheck int
                err := common.DB.QueryRow(`
                        SELECT 1 FROM user_calendar 
                        WHERE user_id = ? AND calendar_id = ? AND deleted_at IS NULL
                `, userData.UserID, calendarData.CalendarID).Scan(&amp;accessCheck)

                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("UserCanAccessCalendarMiddleware: Accès refusé", "user_id", userData.UserID, "calendar_id", calendarData.CalendarID, "error", err.Error())
                        // Si le calendrier existe mais pas d'accès, retourner explicitement 403
                        c.JSON(http.StatusForbidden, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrNoAccessToCalendar,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">slog.Info("UserCanAccessCalendarMiddleware: Accès autorisé", "user_id", userData.UserID, "calendar_id", calendarData.CalendarID)
                c.Next()</span>
        }
}

func LoggingMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                c.Next()
                latency := time.Since(start)

                status := c.Writer.Status()
                method := c.Request.Method
                path := c.Request.URL.Path
                clientIP := c.ClientIP()

                slog.Info(common.LogHTTPReceivedRequest,
                        slog.String("method", method),
                        slog.String("path", path),
                        slog.Int("status", status),
                        slog.String("ip", clientIP),
                        slog.Duration("latency", latency),
                )
        }</span>
}

// AuthMiddleware vérifie l'authentification de l'utilisateur via le token de session
func AuthMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Récupérer le token depuis le header Authorization
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        slog.Error(common.LogMissingAuthHeader)
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserNotAuthenticated,
                        })
                        c.Abort()
                        return
                }</span>

                // Extraire le token (format: "Bearer &lt;token&gt;")
                <span class="cov8" title="1">token := extractTokenFromHeader(authHeader)
                if token == "" </span><span class="cov8" title="1">{
                        slog.Error(common.LogInvalidToken)
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrSessionInvalid,
                        })
                        c.Abort()
                        return
                }</span>

                // Valider la session
                <span class="cov8" title="1">user, err := session.Session.ValidateSession(token)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error(common.LogInvalidSession + ": " + err.Error())
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrSessionInvalid,
                        })
                        c.Abort()
                        return
                }</span>

                // Ajouter l'utilisateur au contexte
                <span class="cov8" title="1">c.Set("auth_user", *user)
                c.Next()</span>
        }
}

// RoleMiddleware vérifie que l'utilisateur a un rôle spécifique
func RoleMiddleware(requiredRole string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userData, ok := common.GetUserFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserNotFoundInContext)
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserNotAuthenticated,
                        })
                        c.Abort()
                        return
                }</span>

                // Vérifier si l'utilisateur a le rôle requis
                <span class="cov8" title="1">var roleID int
                err := common.DB.QueryRow(`
                        SELECT r.role_id
                        FROM roles r
                        INNER JOIN user_roles ur ON r.role_id = ur.role_id
                        WHERE ur.user_id = ? AND r.name = ? AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                `, userData.UserID, requiredRole).Scan(&amp;roleID)

                if err != nil </span><span class="cov8" title="1">{
                        slog.Error(fmt.Sprintf(common.LogUserMissingRole, requiredRole))
                        c.JSON(http.StatusForbidden, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInsufficientPermissions,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// RolesMiddleware vérifie que l'utilisateur a au moins un des rôles spécifiés
func RolesMiddleware(requiredRoles ...string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                userData, ok := common.GetUserFromContext(c)
                if !ok </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserNotFoundInContext)
                        c.JSON(http.StatusUnauthorized, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserNotAuthenticated,
                        })
                        c.Abort()
                        return
                }</span>

                // Construire la requête pour vérifier si l'utilisateur a au moins un des rôles
                <span class="cov8" title="1">placeholders := make([]string, len(requiredRoles))
                args := make([]interface{}, len(requiredRoles)+1)
                args[0] = userData.UserID

                for i, role := range requiredRoles </span><span class="cov8" title="1">{
                        placeholders[i] = "?"
                        args[i+1] = role
                }</span>

                <span class="cov8" title="1">query := `
                        SELECT COUNT(*) 
                        FROM roles r
                        INNER JOIN user_roles ur ON r.role_id = ur.role_id
                        WHERE ur.user_id = ? AND r.name IN (` + strings.Join(placeholders, ",") + `) 
                        AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                `

                var count int
                err := common.DB.QueryRow(query, args...).Scan(&amp;count)

                if err != nil || count == 0 </span><span class="cov8" title="1">{
                        slog.Error("Utilisateur n'a aucun des rôles requis: " + strings.Join(requiredRoles, ", "))
                        c.JSON(http.StatusForbidden, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInsufficientPermissions,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// AdminMiddleware vérifie que l'utilisateur a le rôle "admin"
func AdminMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return RoleMiddleware("admin")
}</span>

// OptionalAuthMiddleware vérifie l'authentification si un token est fourni, sinon continue sans authentification
func OptionalAuthMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Récupérer le token depuis le header Authorization
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        // Pas de token, on continue sans authentification
                        c.Next()
                        return
                }</span>

                // Extraire le token
                <span class="cov8" title="1">token := extractTokenFromHeader(authHeader)
                if token == "" </span><span class="cov0" title="0">{
                        // Token invalide, on continue sans authentification
                        c.Next()
                        return
                }</span>

                // Valider la session
                <span class="cov8" title="1">user, err := session.Session.ValidateSession(token)
                if err != nil </span><span class="cov8" title="1">{
                        // Session invalide, on continue sans authentification
                        slog.Warn(common.LogSessionInvalidOptional + ": " + err.Error())
                        c.Next()
                        return
                }</span>

                // Ajouter l'utilisateur au contexte
                <span class="cov0" title="0">c.Set("auth_user", *user)
                c.Next()</span>
        }
}

// extractTokenFromHeader extrait le token du header Authorization
func extractTokenFromHeader(authHeader string) string <span class="cov8" title="1">{
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov8" title="1">{
                return authHeader[7:]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// EventExistsMiddleware vérifie l'existence d'un événement à partir d'un paramètre dans l'URL
// paramName: nom du paramètre à vérifier (ex: "id", "event_id")
func EventExistsMiddleware(paramName string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                eventIDStr := c.Param(paramName)
                eventID, err := strconv.Atoi(eventIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInvalidEventID,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">var event common.Event
                err = common.DB.QueryRow(
                        "SELECT event_id, title, description, start, duration, canceled, created_at, updated_at, deleted_at FROM event WHERE event_id = ? AND deleted_at IS NULL",
                        eventID,
                ).Scan(
                        &amp;event.EventID,
                        &amp;event.Title,
                        &amp;event.Description,
                        &amp;event.Start,
                        &amp;event.Duration,
                        &amp;event.Canceled,
                        &amp;event.CreatedAt,
                        &amp;event.UpdatedAt,
                        &amp;event.DeletedAt,
                )

                if common.HandleDBError(c, err, http.StatusNotFound, common.ErrEventNotFound, common.ErrEventRetrieval) </span><span class="cov8" title="1">{
                        return
                }</span>

                // L'événement existe, on l'ajoute au contexte et on continue
                <span class="cov8" title="1">c.Set("event", event)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package role internal/role/role.go
package role

import (
        "database/sql"
        "fmt"
        "go-averroes/internal/common"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

type RoleStruct struct{}

var Role = RoleStruct{}

// GetRole récupère un rôle par son ID
func (RoleStruct) GetRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleGet)

        roleID := c.Param("id")
        if roleID == "" </span><span class="cov0" title="0">{
                slog.Error(common.ErrMissingRoleID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrMissingRoleID,
                })
                return
        }</span>

        // Vérifier si l'ID est numérique
        <span class="cov8" title="1">if _, err := strconv.Atoi(roleID); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.ErrMissingRoleID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrMissingRoleID,
                })
                return
        }</span>

        <span class="cov8" title="1">var role common.Role
        err := common.DB.QueryRow(`
                SELECT role_id, name, description, created_at, updated_at, deleted_at
                FROM roles 
                WHERE role_id = ? AND deleted_at IS NULL
        `, roleID).Scan(&amp;role.RoleID, &amp;role.Name, &amp;role.Description, &amp;role.CreatedAt, &amp;role.UpdatedAt, &amp;role.DeletedAt)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrRoleNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la récupération du rôle: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info("Rôle récupéré avec succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    role,
        })</span>
}

// ListRoles récupère tous les rôles
func (RoleStruct) ListRoles(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleList)

        rows, err := common.DB.Query(`
                SELECT role_id, name, description, created_at, updated_at, deleted_at
                FROM roles 
                WHERE deleted_at IS NULL
                ORDER BY name
        `)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogRolesRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var roles []common.Role
        for rows.Next() </span><span class="cov8" title="1">{
                var role common.Role
                err := rows.Scan(&amp;role.RoleID, &amp;role.Name, &amp;role.Description, &amp;role.CreatedAt, &amp;role.UpdatedAt, &amp;role.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Erreur lors de la lecture du rôle: " + err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">roles = append(roles, role)</span>
        }

        <span class="cov8" title="1">slog.Info("Rôles récupérés avec succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    roles,
        })</span>
}

// CreateRole crée un nouveau rôle
func (RoleStruct) CreateRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleCreate)

        var req common.CreateRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(fmt.Sprintf(common.LogInvalidData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si le nom du rôle existe déjà
        <span class="cov8" title="1">var existingID int
        err := common.DB.QueryRow("SELECT role_id FROM roles WHERE name = ? AND deleted_at IS NULL", req.Name).Scan(&amp;existingID)
        if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error("Rôle déjà existant")
                c.JSON(http.StatusConflict, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleAlreadyExists,
                })
                return
        }</span>

        <span class="cov8" title="1">result, err := common.DB.Exec(`
                INSERT INTO roles (name, description, created_at) 
                VALUES (?, ?, NOW())
        `, req.Name, req.Description)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la création du rôle: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">roleID, _ := result.LastInsertId()

        slog.Info(common.LogRoleCreateSuccess)
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessCreateRole,
                Data:    gin.H{"role_id": roleID},
        })</span>
}

// UpdateRole met à jour un rôle existant
func (RoleStruct) UpdateRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleUpdate)

        var req common.UpdateRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogInvalidData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        <span class="cov8" title="1">roleID := c.Param("id")
        if roleID == "" </span><span class="cov0" title="0">{
                slog.Error(common.ErrMissingRoleID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si le rôle existe
        <span class="cov8" title="1">var existingRole common.Role
        err := common.DB.QueryRow("SELECT role_id FROM roles WHERE role_id = ? AND deleted_at IS NULL", roleID).Scan(&amp;existingRole.RoleID)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                slog.Error(common.ErrRoleNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        // Vérifier si le nouveau nom existe déjà (si fourni)
        <span class="cov8" title="1">if req.Name != nil </span><span class="cov8" title="1">{
                var existingID int
                err = common.DB.QueryRow("SELECT role_id FROM roles WHERE name = ? AND role_id != ? AND deleted_at IS NULL", *req.Name, roleID).Scan(&amp;existingID)
                if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        slog.Error(common.ErrRoleNameAlreadyUsed)
                        c.JSON(http.StatusConflict, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrRoleAlreadyExists,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">query := "UPDATE roles SET updated_at = NOW()"
        var args []interface{}

        if req.Name != nil </span><span class="cov8" title="1">{
                query += ", name = ?"
                args = append(args, *req.Name)
        }</span>
        <span class="cov8" title="1">if req.Description != nil </span><span class="cov8" title="1">{
                query += ", description = ?"
                args = append(args, *req.Description)
        }</span>

        <span class="cov8" title="1">args = append(args, roleID)
        _, err = common.DB.Exec(query+" WHERE role_id = ?", args...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.ErrRoleUpdateFailed + ": " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogRoleUpdateSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUpdateRole,
        })</span>
}

// DeleteRole supprime un rôle
func (RoleStruct) DeleteRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleDelete)

        roleID := c.Param("id")
        if roleID == "" </span><span class="cov0" title="0">{
                slog.Error(common.ErrMissingRoleID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrMissingRoleID,
                })
                return
        }</span>

        // Vérifier si l'ID est numérique
        <span class="cov8" title="1">if _, err := strconv.Atoi(roleID); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.ErrMissingRoleID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrMissingRoleID,
                })
                return
        }</span>

        // Vérifier si le rôle existe
        <span class="cov8" title="1">var existingRole common.Role
        err := common.DB.QueryRow("SELECT role_id, name FROM roles WHERE role_id = ? AND deleted_at IS NULL", roleID).Scan(&amp;existingRole.RoleID, &amp;existingRole.Name)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrRoleNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        // Empêcher la suppression du rôle admin
        <span class="cov8" title="1">if existingRole.Name == "admin" </span><span class="cov8" title="1">{
                slog.Error("Tentative de suppression du rôle admin")
                c.JSON(http.StatusForbidden, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInsufficientPermissions,
                })
                return
        }</span>

        // Soft delete du rôle
        <span class="cov0" title="0">_, err = common.DB.Exec("UPDATE roles SET deleted_at = NOW() WHERE role_id = ?", roleID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.ErrRoleDeleteFailed + ": " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleDelete,
                })
                return
        }</span>

        // Supprimer aussi les attributions de rôles
        <span class="cov0" title="0">_, err = common.DB.Exec("UPDATE user_roles SET deleted_at = NOW() WHERE role_id = ?", roleID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la suppression des attributions de rôles: " + err.Error())
                // On continue quand même car le rôle a été supprimé
        }</span>

        <span class="cov0" title="0">slog.Info(common.LogRoleDeleteSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessDeleteRole,
        })</span>
}

// AssignRole attribue un rôle à un utilisateur
func (RoleStruct) AssignRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleAssign)

        var req common.AssignRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(fmt.Sprintf(common.LogInvalidData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si l'utilisateur existe
        <span class="cov8" title="1">var userID int
        err := common.DB.QueryRow("SELECT user_id FROM user WHERE user_id = ? AND deleted_at IS NULL", req.UserID).Scan(&amp;userID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrUserNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotFound,
                })
                return
        }</span>

        // Vérifier si le rôle existe
        <span class="cov8" title="1">var roleID int
        err = common.DB.QueryRow("SELECT role_id FROM roles WHERE role_id = ? AND deleted_at IS NULL", req.RoleID).Scan(&amp;roleID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrRoleNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        // Vérifier si l'attribution existe déjà
        <span class="cov8" title="1">var existingID int
        err = common.DB.QueryRow("SELECT user_roles_id FROM user_roles WHERE user_id = ? AND role_id = ? AND deleted_at IS NULL", req.UserID, req.RoleID).Scan(&amp;existingID)
        if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrRoleAttributionConflict)
                c.JSON(http.StatusConflict, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleAlreadyAssigned,
                })
                return
        }</span>

        // Créer l'attribution
        <span class="cov8" title="1">_, err = common.DB.Exec(`
                INSERT INTO user_roles (user_id, role_id, created_at) 
                VALUES (?, ?, NOW())
        `, req.UserID, req.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.ErrRoleAssignmentFailed + ": " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleAssignment,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogRoleAssignSuccess)
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessAssignRole,
        })</span>
}

// RevokeRole révoque un rôle d'un utilisateur
func (RoleStruct) RevokeRole(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleRevoke)

        var req common.AssignRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(fmt.Sprintf(common.LogInvalidData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si l'attribution existe
        <span class="cov8" title="1">var userRoleID int
        err := common.DB.QueryRow("SELECT user_roles_id FROM user_roles WHERE user_id = ? AND role_id = ? AND deleted_at IS NULL", req.UserID, req.RoleID).Scan(&amp;userRoleID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error("Attribution de rôle non trouvée")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   "Ce rôle n'est pas attribué à cet utilisateur",
                })
                return
        }</span>

        // Supprimer l'attribution
        <span class="cov8" title="1">_, err = common.DB.Exec("UPDATE user_roles SET deleted_at = NOW() WHERE user_roles_id = ?", userRoleID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.ErrRoleRevocationFailed + ": " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleRevocation,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogRoleRevokeSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessRevokeRole,
        })</span>
}

// GetUserRoles récupère les rôles d'un utilisateur
func (RoleStruct) GetUserRoles(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRoleGetUserRoles)

        userID := c.Param("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                slog.Error(common.LogMissingUserID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si l'utilisateur existe
        <span class="cov8" title="1">var existingUserID int
        err := common.DB.QueryRow("SELECT user_id FROM user WHERE user_id = ? AND deleted_at IS NULL", userID).Scan(&amp;existingUserID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrUserNotFound)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotFound,
                })
                return
        }</span>

        <span class="cov8" title="1">rows, err := common.DB.Query(`
                SELECT r.role_id, r.name, r.description, r.created_at, r.updated_at, r.deleted_at
                FROM roles r
                INNER JOIN user_roles ur ON r.role_id = ur.role_id
                WHERE ur.user_id = ? AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                ORDER BY r.name
        `, userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogRolesRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var roles []common.Role
        for rows.Next() </span><span class="cov8" title="1">{
                var role common.Role
                err := rows.Scan(&amp;role.RoleID, &amp;role.Name, &amp;role.Description, &amp;role.CreatedAt, &amp;role.UpdatedAt, &amp;role.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Erreur lors de la lecture du rôle: " + err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">roles = append(roles, role)</span>
        }

        <span class="cov8" title="1">slog.Info(common.LogUserRolesRetrieved)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    roles,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package routes

import (
        "go-averroes/internal/calendar"
        "go-averroes/internal/calendar_event"
        "go-averroes/internal/middleware"
        "go-averroes/internal/role"
        "go-averroes/internal/session"
        "go-averroes/internal/user"
        "go-averroes/internal/user_calendar"
        "net/http"

        "github.com/gin-gonic/gin"
)

func RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Health check endpoint (public)
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":  "healthy",
                        "service": "GoLendar API",
                })
        }</span>)

        // ===== ROUTES D'AUTHENTIFICATION (publiques) =====
        <span class="cov0" title="0">authGroup := router.Group("/auth")
        </span><span class="cov0" title="0">{
                authGroup.POST("/login", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.Login(c) }</span>)
                <span class="cov0" title="0">authGroup.POST("/refresh", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.RefreshToken(c) }</span>)
        }

        // ===== ROUTES D'AUTHENTIFICATION (protégées) =====
        <span class="cov0" title="0">authProtectedGroup := router.Group("/auth")
        authProtectedGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                authProtectedGroup.POST("/logout", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.Logout(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.GET("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.GetAuthMe(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.GET("/sessions", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.GetUserSessions(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.DELETE("/sessions/:session_id", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.DeleteSession(c) }</span>)
        }

        // ===== ROUTES DE GESTION DES UTILISATEURS =====
        <span class="cov0" title="0">userGroup := router.Group("/user")
        </span><span class="cov0" title="0">{
                // Création d'utilisateur (public - inscription)
                userGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Add(c) }</span>)

                // Routes protégées par authentification
                <span class="cov0" title="0">userProtectedGroup := userGroup.Group("")
                userProtectedGroup.Use(middleware.AuthMiddleware())
                </span><span class="cov0" title="0">{
                        // L'utilisateur peut accéder à ses propres données
                        userProtectedGroup.GET("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Get(c) }</span>)
                        <span class="cov0" title="0">userProtectedGroup.PUT("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Update(c) }</span>)
                        <span class="cov0" title="0">userProtectedGroup.DELETE("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Delete(c) }</span>)
                }

                // Routes admin pour gérer tous les utilisateurs
                <span class="cov0" title="0">userAdminGroup := userGroup.Group("")
                userAdminGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
                </span><span class="cov0" title="0">{
                        userAdminGroup.GET("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Get(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.PUT("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Update(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.DELETE("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Delete(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.GET("/:user_id/with-roles", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.GetUserWithRoles(c) }</span>)
                }
        }

        // ===== ROUTES DE GESTION DES RÔLES (admin uniquement) =====
        <span class="cov0" title="0">roleGroup := router.Group("/roles")
        roleGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
        </span><span class="cov0" title="0">{
                roleGroup.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.ListRoles(c) }</span>)
                <span class="cov0" title="0">roleGroup.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.GetRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.CreateRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.PUT("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.UpdateRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.DELETE("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.DeleteRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("/assign", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.AssignRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("/revoke", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.RevokeRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.GET("/user/:user_id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.GetUserRoles(c) }</span>)
        }

        // ===== ROUTES DE GESTION DES LIAISONS USER-CALENDAR (admin uniquement) =====
        <span class="cov0" title="0">userCalendarGroup := router.Group("/user-calendar")
        userCalendarGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
        </span><span class="cov0" title="0">{
                userCalendarGroup.GET("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Get(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.GET("/:user_id",
                        middleware.UserExistsMiddleware("user_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.List(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.POST("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Add(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.PUT("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Update(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.DELETE("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Delete(c) }</span>,
                )
        }

        // ===== ROUTES DE GESTION DES CALENDRERS =====
        <span class="cov0" title="0">calendarGroup := router.Group("/calendar")
        calendarGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // L'utilisateur peut créer des calendriers
                calendarGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Add(c) }</span>)

                // L'utilisateur peut accéder aux calendriers auxquels il a accès
                <span class="cov0" title="0">calendarGroup.GET("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Get(c) }</span>,
                )
                <span class="cov0" title="0">calendarGroup.PUT("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Update(c) }</span>,
                )
                <span class="cov0" title="0">calendarGroup.DELETE("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Delete(c) }</span>,
                )
        }

        // ===== ROUTES DE GESTION DES ÉVÉNEMENTS =====
        <span class="cov0" title="0">calendarEventGroup := router.Group("/calendar-event")
        calendarEventGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // Toutes les routes d'événements nécessitent l'accès au calendrier
                calendarEventGroup.GET("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Get(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/month/:year/:month",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByMonth(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/week/:year/:week",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByWeek(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/day/:year/:month/:day",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByDay(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.POST("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Add(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.PUT("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Update(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.DELETE("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Delete(c) }</span>,
                )
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package session internal/session/session.go
package session

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "go-averroes/internal/common"
        "log/slog"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
)

type SessionStruct struct{}

var Session = SessionStruct{}

// Login authentifie un utilisateur et crée une session
func (SessionStruct) Login(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogLoginAttempt)
        var req struct {
                Email    string `json:"email" binding:"required,email"`
                Password string `json:"password" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(fmt.Sprintf(common.LogInvalidLoginData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Récupérer l'utilisateur et son mot de passe
        <span class="cov8" title="1">var user common.User
        var passwordHash string
        err := common.DB.QueryRow(`
                SELECT u.user_id, u.lastname, u.firstname, u.email, u.created_at, u.updated_at, u.deleted_at, up.password_hash
                FROM user u
                INNER JOIN user_password up ON u.user_id = up.user_id
                WHERE u.email = ? AND u.deleted_at IS NULL AND up.deleted_at IS NULL
        `, req.Email).Scan(
                &amp;user.UserID,
                &amp;user.Lastname,
                &amp;user.Firstname,
                &amp;user.Email,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
                &amp;user.DeletedAt,
                &amp;passwordHash,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.ErrUserNotFound)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidCredentials,
                        Data:    req,
                })
                return
        }</span>

        // Vérifier le mot de passe
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(req.Password))
        if err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogInvalidPassword)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidCredentials,
                        Data:    req,
                })
                return
        }</span>

        // Récupérer les rôles de l'utilisateur
        <span class="cov8" title="1">roles, err := GetUserRoles(user.UserID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogRolesRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>

        // Générer les tokens
        <span class="cov8" title="1">sessionToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la génération du token de session: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTokenGeneration,
                })
                return
        }</span>

        <span class="cov8" title="1">refreshToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la génération du refresh token: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTokenGeneration,
                })
                return
        }</span>

        // Définir l'expiration (1 heure pour le session token)
        <span class="cov8" title="1">sessionExpiresAt := time.Now().Add(1 * time.Hour)

        // Récupérer les informations de l'appareil
        deviceInfo := c.GetHeader("User-Agent")
        ipAddress := c.ClientIP()

        // Créer la session en base
        _, err = common.DB.Exec(`
                INSERT INTO user_session (user_id, session_token, refresh_token, expires_at, device_info, ip_address, is_active, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, TRUE, NOW())
        `, user.UserID, sessionToken, refreshToken, sessionExpiresAt, deviceInfo, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la création de la session: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">response := common.LoginResponse{
                User:         user,
                SessionToken: sessionToken,
                RefreshToken: refreshToken,
                ExpiresAt:    sessionExpiresAt,
                Roles:        roles,
        }

        slog.Info(fmt.Sprintf(common.LogLoginSuccess, user.Email))
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessLogin,
                Data:    response,
        })</span>
}

// Logout déconnecte un utilisateur en supprimant sa session
func (SessionStruct) Logout(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogLogoutAttempt)

        // Récupérer le token depuis le header Authorization
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                slog.Error(common.LogMissingAuthHeader)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        // Extraire le token (format: "Bearer &lt;token&gt;")
        <span class="cov8" title="1">token := extractTokenFromHeader(authHeader)
        if token == "" </span><span class="cov0" title="0">{
                slog.Error(common.LogInvalidToken)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionInvalid,
                })
                return
        }</span>

        // Désactiver la session
        <span class="cov8" title="1">_, err := common.DB.Exec(`
                UPDATE user_session 
                SET is_active = FALSE, updated_at = NOW() 
                WHERE session_token = ? AND is_active = TRUE
        `, token)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Erreur lors de la déconnexion: " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionDeletion,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogLogoutSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessLogout,
        })</span>
}

// RefreshToken rafraîchit un token de session
func (SessionStruct) RefreshToken(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogRefreshTokenAttempt)

        var req struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(fmt.Sprintf(common.LogInvalidData, err.Error()))
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier le refresh token
        <span class="cov8" title="1">var session common.UserSession
        err := common.DB.QueryRow(`
                SELECT user_session_id, user_id, session_token, refresh_token, expires_at, device_info, ip_address, is_active, created_at, updated_at, deleted_at
                FROM user_session 
                WHERE refresh_token = ? AND is_active = TRUE AND deleted_at IS NULL
        `, req.RefreshToken).Scan(
                &amp;session.UserSessionID,
                &amp;session.UserID,
                &amp;session.SessionToken,
                &amp;session.RefreshToken,
                &amp;session.ExpiresAt,
                &amp;session.DeviceInfo,
                &amp;session.IPAddress,
                &amp;session.IsActive,
                &amp;session.CreatedAt,
                &amp;session.UpdatedAt,
                &amp;session.DeletedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.LogInvalidRefreshToken)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionInvalid,
                })
                return
        }</span>

        // Vérifier si le refresh token n'est pas expiré
        <span class="cov8" title="1">if time.Now().After(session.ExpiresAt) </span><span class="cov8" title="1">{
                slog.Error(common.LogRefreshTokenExpired)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionExpired,
                })
                return
        }</span>

        // Générer un nouveau session token
        <span class="cov8" title="1">newSessionToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogTokenGenerationError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTokenGeneration,
                })
                return
        }</span>

        // Mettre à jour la session avec le nouveau token
        <span class="cov8" title="1">newExpiresAt := time.Now().Add(1 * time.Hour)
        _, err = common.DB.Exec(`
                UPDATE user_session 
                SET session_token = ?, expires_at = ?, updated_at = NOW() 
                WHERE user_session_id = ?
        `, newSessionToken, newExpiresAt, session.UserSessionID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogSessionUpdateError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogTokenRefreshSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessRefreshToken,
                Data: gin.H{
                        "session_token": newSessionToken,
                        "expires_at":    newExpiresAt,
                },
        })</span>
}

// GetUserSessions récupère toutes les sessions d'un utilisateur
func (SessionStruct) GetUserSessions(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogGetUserSessions)

        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserNotFoundInContext)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">rows, err := common.DB.Query(`
                SELECT user_session_id, user_id, session_token, refresh_token, expires_at, device_info, ip_address, is_active, created_at, updated_at, deleted_at
                FROM user_session 
                WHERE user_id = ? AND deleted_at IS NULL
                ORDER BY created_at DESC
        `, userData.UserID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogSessionsRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var sessions []common.UserSession
        for rows.Next() </span><span class="cov8" title="1">{
                var session common.UserSession
                err := rows.Scan(&amp;session.UserSessionID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken, &amp;session.ExpiresAt, &amp;session.DeviceInfo, &amp;session.IPAddress, &amp;session.IsActive, &amp;session.CreatedAt, &amp;session.UpdatedAt, &amp;session.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(fmt.Sprintf(common.LogSessionReadingError, err.Error()))
                        continue</span>
                }
                // Masquer les tokens pour la sécurité
                <span class="cov8" title="1">session.SessionToken = "***"
                session.RefreshToken = nil
                sessions = append(sessions, session)</span>
        }

        <span class="cov8" title="1">slog.Info(common.LogSessionsRetrieved)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    sessions,
        })</span>
}

// DeleteSession supprime une session spécifique
func (SessionStruct) DeleteSession(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogDeleteSession)

        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserNotFoundInContext)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">sessionID := c.Param("session_id")
        if sessionID == "" </span><span class="cov0" title="0">{
                slog.Error(common.LogMissingSessionID)
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier que la session appartient à l'utilisateur
        <span class="cov8" title="1">var existingSessionID int
        err := common.DB.QueryRow("SELECT user_session_id FROM user_session WHERE user_session_id = ? AND user_id = ? AND deleted_at IS NULL", sessionID, userData.UserID).Scan(&amp;existingSessionID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.LogSessionNotFoundOrNotOwned)
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionNotFound,
                })
                return
        }</span>

        // Supprimer la session
        <span class="cov8" title="1">_, err = common.DB.Exec("UPDATE user_session SET deleted_at = NOW() WHERE user_session_id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogSessionDeletionError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrSessionDeletion,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogSessionDeletedSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessDeleteSession,
        })</span>
}

// ValidateSession valide un token de session (utilisé par le middleware)
func (SessionStruct) ValidateSession(token string) (*common.User, error) <span class="cov8" title="1">{
        var user common.User
        var expiresAt time.Time
        err := common.DB.QueryRow(`
                SELECT u.user_id, u.lastname, u.firstname, u.email, u.created_at, u.updated_at, u.deleted_at, us.expires_at
                FROM user u
                INNER JOIN user_session us ON u.user_id = us.user_id
                WHERE us.session_token = ? AND us.is_active = TRUE AND us.deleted_at IS NULL AND u.deleted_at IS NULL
        `, token).Scan(
                &amp;user.UserID,
                &amp;user.Lastname,
                &amp;user.Firstname,
                &amp;user.Email,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
                &amp;user.DeletedAt,
                &amp;expiresAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, errors.New(common.ErrSessionNotFound)
        }</span>

        <span class="cov8" title="1">if time.Now().After(expiresAt) </span><span class="cov8" title="1">{
                return nil, errors.New(common.ErrSessionExpired)
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

// Fonctions utilitaires

// generateToken génère un token aléatoire
func generateToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

// extractTokenFromHeader extrait le token du header Authorization
func extractTokenFromHeader(authHeader string) string <span class="cov8" title="1">{
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov8" title="1">{
                return authHeader[7:]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUserRoles récupère les rôles d'un utilisateur
func GetUserRoles(userID int) ([]common.Role, error) <span class="cov8" title="1">{
        rows, err := common.DB.Query(`
                SELECT r.role_id, r.name, r.description, r.created_at, r.updated_at, r.deleted_at
                FROM roles r
                INNER JOIN user_roles ur ON r.role_id = ur.role_id
                WHERE ur.user_id = ? AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                ORDER BY r.name
        `, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var roles []common.Role
        for rows.Next() </span><span class="cov0" title="0">{
                var role common.Role
                err := rows.Scan(
                        &amp;role.RoleID,
                        &amp;role.Name,
                        &amp;role.Description,
                        &amp;role.CreatedAt,
                        &amp;role.UpdatedAt,
                        &amp;role.DeletedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">roles = append(roles, role)</span>
        }

        <span class="cov8" title="1">return roles, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package user internal/user/user.go
package user

import (
        "database/sql"
        "fmt"
        "go-averroes/internal/common"
        "log/slog"
        "net/http"
        "regexp"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
)

type UserStruct struct{}

var User = UserStruct{}

// Get récupère un utilisateur par son ID
func (UserStruct) Get(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserGet)
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserGet + " - utilisateur non trouvé dans le contexte")
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserGet + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    userData,
        })</span>
}

// Add crée un nouvel utilisateur
func (UserStruct) Add(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserAdd)
        var req common.CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                slog.Error(common.LogUserAdd + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        // Vérifier si l'email existe déjà
        <span class="cov8" title="1">var existingID int
        err := common.DB.QueryRow("SELECT user_id FROM user WHERE email = ? AND deleted_at IS NULL", req.Email).Scan(&amp;existingID)
        if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                slog.Error(common.LogUserAdd + " - utilisateur déjà existant")
                c.JSON(http.StatusConflict, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserAlreadyExists,
                })
                return
        }</span>

        // Hasher le mot de passe
        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserAdd + " - erreur lors du hash du mot de passe : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrPasswordHashing,
                })
                return
        }</span>

        <span class="cov8" title="1">tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserAdd + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        result, err := tx.Exec(`
                INSERT INTO user (lastname, firstname, email, created_at) 
                VALUES (?, ?, ?, NOW())
        `, req.Lastname, req.Firstname, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserAdd + " - erreur lors de la création de l'utilisateur : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">userID, _ := result.LastInsertId()

        _, err = tx.Exec(`
                INSERT INTO user_password (user_id, password_hash, created_at) 
                VALUES (?, ?, NOW())
        `, userID, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserAdd + " - erreur lors de la création du mot de passe : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrPasswordCreation,
                })
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserAdd + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserAdd + " - succès")
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessCreateUser,
                Data:    gin.H{"user_id": userID},
        })</span>
}

// Update met à jour un utilisateur
func (UserStruct) Update(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserUpdate)
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserUpdate + " - utilisateur non trouvé dans le contexte")
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>
        <span class="cov8" title="1">userID := userData.UserID

        var req common.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserUpdate + " - données invalides : " + err.Error())
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidData,
                })
                return
        }</span>

        <span class="cov8" title="1">if req.Email != nil </span><span class="cov8" title="1">{
                emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
                if !emailRegex.MatchString(*req.Email) </span><span class="cov8" title="1">{
                        slog.Error(common.LogUserUpdate + " - format email invalide")
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrInvalidEmailFormat,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">if req.Password != nil </span><span class="cov8" title="1">{
                if len(*req.Password) &lt; 6 </span><span class="cov8" title="1">{
                        slog.Error(common.LogUserUpdate + " - mot de passe trop court")
                        c.JSON(http.StatusBadRequest, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrPasswordTooShort,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserUpdate + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        query := "UPDATE user SET updated_at = NOW()"
        var args []interface{}

        if req.Lastname != nil </span><span class="cov8" title="1">{
                query += ", lastname = ?"
                args = append(args, *req.Lastname)
        }</span>
        <span class="cov8" title="1">if req.Firstname != nil </span><span class="cov8" title="1">{
                query += ", firstname = ?"
                args = append(args, *req.Firstname)
        }</span>
        <span class="cov8" title="1">if req.Email != nil </span><span class="cov8" title="1">{
                var existingID int
                err = tx.QueryRow("SELECT user_id FROM user WHERE email = ? AND user_id != ? AND deleted_at IS NULL", *req.Email, userID).Scan(&amp;existingID)
                if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                        slog.Error(common.LogUserUpdate + " - email déjà utilisé")
                        c.JSON(http.StatusConflict, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserAlreadyExists,
                        })
                        return
                }</span>
                <span class="cov8" title="1">query += ", email = ?"
                args = append(args, *req.Email)</span>
        }

        <span class="cov8" title="1">query += " WHERE user_id = ?"
        args = append(args, userID)

        _, err = tx.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserUpdate + " - erreur lors de la mise à jour de l'utilisateur : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">if req.Password != nil </span><span class="cov8" title="1">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserUpdate + " - erreur lors du hash du mot de passe : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrPasswordHashing,
                        })
                        return
                }</span>

                <span class="cov8" title="1">_, err = tx.Exec(`
                        UPDATE user_password 
                        SET password_hash = ?, updated_at = NOW() 
                        WHERE user_id = ?
                `, string(hashedPassword), userID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserUpdate + " - erreur lors de la mise à jour du mot de passe : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrPasswordUpdate,
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserUpdate + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserUpdate + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUserUpdate,
        })</span>
}

// Delete supprime un utilisateur (soft delete)
func (UserStruct) Delete(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserDelete)
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserDelete + " - utilisateur non trouvé dans le contexte")
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>
        <span class="cov8" title="1">userID := userData.UserID

        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserDelete + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        _, err = tx.Exec("UPDATE user SET deleted_at = NOW() WHERE user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserDelete + " - erreur lors de la suppression de l'utilisateur : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserDelete,
                })
                return
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec("UPDATE user_password SET deleted_at = NOW() WHERE user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserDelete + " - erreur lors de la suppression du mot de passe : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrPasswordDelete,
                })
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserDelete + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserDelete + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUserDelete,
        })</span>
}

// GetUserWithRoles récupère un utilisateur avec ses rôles
func (UserStruct) GetUserWithRoles(c *gin.Context) <span class="cov8" title="1">{
        slog.Info("Récupération d'un utilisateur avec ses rôles")
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserNotFoundInContext)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        // Récupérer les rôles de l'utilisateur
        <span class="cov8" title="1">rows, err := common.DB.Query(`
                SELECT r.role_id, r.name, r.description, r.created_at, r.updated_at, r.deleted_at
                FROM roles r
                INNER JOIN user_roles ur ON r.role_id = ur.role_id
                WHERE ur.user_id = ? AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                ORDER BY r.name
        `, userData.UserID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogRolesRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var roles []common.Role
        for rows.Next() </span><span class="cov8" title="1">{
                var role common.Role
                err := rows.Scan(&amp;role.RoleID, &amp;role.Name, &amp;role.Description, &amp;role.CreatedAt, &amp;role.UpdatedAt, &amp;role.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Erreur lors de la lecture du rôle: " + err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">roles = append(roles, role)</span>
        }

        <span class="cov8" title="1">userWithRoles := common.UserWithRoles{
                User:  userData,
                Roles: roles,
        }

        slog.Info(common.LogUserGetWithRolesSuccess)
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    userWithRoles,
        })</span>
}

// GetAuthMe récupère les informations de l'utilisateur authentifié avec ses rôles
func (UserStruct) GetAuthMe(c *gin.Context) <span class="cov0" title="0">{
        slog.Info(common.LogUserGetWithRoles)

        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                slog.Error(common.LogUserNotFoundInContext)
                c.JSON(http.StatusUnauthorized, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserNotAuthenticated,
                })
                return
        }</span>

        // Récupérer les rôles de l'utilisateur
        <span class="cov0" title="0">rows, err := common.DB.Query(`
                SELECT r.role_id, r.name, r.description, r.created_at, r.updated_at, r.deleted_at
                FROM roles r
                INNER JOIN user_roles ur ON r.role_id = ur.role_id
                WHERE ur.user_id = ? AND ur.deleted_at IS NULL AND r.deleted_at IS NULL
                ORDER BY r.name
        `, userData.UserID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(fmt.Sprintf(common.LogRolesRetrievalError, err.Error()))
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrRoleNotFound,
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roles []common.Role
        for rows.Next() </span><span class="cov0" title="0">{
                var role common.Role
                err := rows.Scan(&amp;role.RoleID, &amp;role.Name, &amp;role.Description, &amp;role.CreatedAt, &amp;role.UpdatedAt, &amp;role.DeletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Erreur lors de la lecture du rôle: " + err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">roles = append(roles, role)</span>
        }

        <span class="cov0" title="0">userWithRoles := common.UserWithRoles{
                User:  userData,
                Roles: roles,
        }

        slog.Info("Utilisateur avec rôles récupéré avec succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    userWithRoles,
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package user_calendar internal/user_calendar/user_calendar.go
package user_calendar

import (
        "database/sql"
        "errors"
        "go-averroes/internal/common"
        "log/slog"
        "net/http"
        "strconv"
        "strings"

        "go-averroes/internal/session"

        "github.com/gin-gonic/gin"
)

type UserCalendarStruct struct{}

var UserCalendar = UserCalendarStruct{}

// Get récupère une liaison user calendar par user_id et calendar_id
func (UserCalendarStruct) Get(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserCalendarGet)
        userID, ok := checkUserAccess(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        var userCalendar common.UserCalendar
        err := common.DB.QueryRow(`
                SELECT user_calendar_id, user_id, calendar_id, created_at, updated_at, deleted_at 
                FROM user_calendar 
                WHERE user_id = ? AND calendar_id = ? AND deleted_at IS NULL
        `, userID, calendarID).Scan(&amp;userCalendar.UserCalendarID, &amp;userCalendar.UserID, &amp;userCalendar.CalendarID, &amp;userCalendar.CreatedAt, &amp;userCalendar.UpdatedAt, &amp;userCalendar.DeletedAt)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        slog.Error(common.LogUserCalendarGet + " - liaison non trouvée")
                        c.JSON(http.StatusNotFound, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserCalendarNotFound,
                        })
                        return
                }</span>
                <span class="cov0" title="0">slog.Error(common.LogUserCalendarGet + " - erreur SQL : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return</span>
        }

        <span class="cov8" title="1">slog.Info(common.LogUserCalendarGet + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Data:    userCalendar,
        })</span>
}

// Add crée une nouvelle liaison user calendar
func (UserCalendarStruct) Add(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserCalendarAdd)
        userID, ok := checkUserAccess(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarAdd + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback() // Rollback par défaut, commit seulement si tout va bien

        // Vérifier si la liaison existe déjà
        var existingLink common.UserCalendar
        err = tx.QueryRow("SELECT user_calendar_id FROM user_calendar WHERE user_id = ? AND calendar_id = ? AND deleted_at IS NULL", userID, calendarID).Scan(&amp;existingLink.UserCalendarID)
        if !errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                slog.Error(common.LogUserCalendarAdd + " - conflit : liaison déjà existante")
                c.JSON(http.StatusConflict, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarConflict,
                })
                return
        }</span>

        // Insérer la liaison
        <span class="cov8" title="1">result, err := tx.Exec(`
                INSERT INTO user_calendar (user_id, calendar_id, created_at) 
                VALUES (?, ?, NOW())
        `, userID, calendarID)
        if err != nil </span><span class="cov0" title="0">{
                // Vérifier si c'est une erreur de doublon MySQL
                if strings.Contains(err.Error(), "Duplicate entry") </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserCalendarAdd + " - " + common.LogUserCalendarConflict)
                        c.JSON(http.StatusConflict, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrUserCalendarConflict,
                        })
                        return
                }</span>
                <span class="cov0" title="0">slog.Error(common.LogUserCalendarAdd + " - " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarLinkCreation,
                })
                return</span>
        }

        <span class="cov8" title="1">userCalendarID, _ := result.LastInsertId()

        // Valider la transaction
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarAdd + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserCalendarAdd + " - succès")
        c.JSON(http.StatusCreated, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessCreateUserCalendar,
                Data:    gin.H{"user_calendar_id": userCalendarID},
        })</span>
}

// Update met à jour une liaison user calendar par user_id et calendar_id
func (UserCalendarStruct) Update(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserCalendarUpdate)
        userID, ok := checkUserAccess(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarUpdate + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Vérifier si la liaison existe
        var existingLink common.UserCalendar
        err = tx.QueryRow("SELECT user_calendar_id FROM user_calendar WHERE user_id = ? AND calendar_id = ? AND deleted_at IS NULL", userID, calendarID).Scan(&amp;existingLink.UserCalendarID)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                slog.Error(common.LogUserCalendarUpdate + " - liaison non trouvée")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarNotFound,
                })
                return
        }</span>

        // Ici, on pourrait mettre à jour d'autres champs si besoin (ex : updated_at).
        <span class="cov8" title="1">_, err = tx.Exec("UPDATE user_calendar SET updated_at = NOW() WHERE user_id = ? AND calendar_id = ?", userID, calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarUpdate + " - erreur lors de la mise à jour de la liaison : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarUpdate,
                })
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarUpdate + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserCalendarUpdate + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessUpdateUserCalendar,
        })</span>
}

// Delete supprime une liaison user-calendar par user_id et calendar_id
func (UserCalendarStruct) Delete(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserCalendarDelete)
        userID, ok := checkUserAccess(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">calendarData, ok := common.GetCalendarFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">calendarID := calendarData.CalendarID

        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarDelete + " - erreur lors du démarrage de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Vérifier si la liaison existe
        var existingLink common.UserCalendar
        err = tx.QueryRow("SELECT user_calendar_id FROM user_calendar WHERE user_id = ? AND calendar_id = ? AND deleted_at IS NULL", userID, calendarID).Scan(&amp;existingLink.UserCalendarID)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                slog.Error(common.LogUserCalendarDelete + " - liaison non trouvée")
                c.JSON(http.StatusNotFound, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarNotFound,
                })
                return
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec("UPDATE user_calendar SET deleted_at = NOW() WHERE user_id = ? AND calendar_id = ?", userID, calendarID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarDelete + " - erreur lors de la suppression de la liaison : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrUserCalendarDelete,
                })
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarDelete + " - erreur lors du commit de la transaction : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionCommit,
                })
                return
        }</span>

        <span class="cov8" title="1">slog.Info(common.LogUserCalendarDelete + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessDeleteUserCalendar,
        })</span>
}

// List récupère toutes les liaisons user calendar pour un utilisateur
func (UserCalendarStruct) List(c *gin.Context) <span class="cov8" title="1">{
        slog.Info(common.LogUserCalendarList)
        userID, ok := checkUserAccess(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rows, err := common.DB.Query(`
                SELECT uc.user_calendar_id, uc.user_id, uc.calendar_id, uc.created_at, uc.updated_at, uc.deleted_at,
                       c.title, c.description
                FROM user_calendar uc
                INNER JOIN calendar c ON uc.calendar_id = c.calendar_id
                WHERE uc.user_id = ? AND uc.deleted_at IS NULL AND c.deleted_at IS NULL
                ORDER BY uc.created_at DESC
        `, userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarList + " - erreur lors de la récupération des liaisons : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var userCalendars []common.UserCalendarWithDetails
        for rows.Next() </span><span class="cov8" title="1">{
                var userCalendar common.UserCalendarWithDetails
                err := rows.Scan(
                        &amp;userCalendar.UserCalendarID,
                        &amp;userCalendar.UserID,
                        &amp;userCalendar.CalendarID,
                        &amp;userCalendar.CreatedAt,
                        &amp;userCalendar.UpdatedAt,
                        &amp;userCalendar.DeletedAt,
                        &amp;userCalendar.Title,
                        &amp;userCalendar.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserCalendarList + " - erreur lors de la lecture des données : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrTransactionStart,
                        })
                        return
                }</span>
                <span class="cov8" title="1">userCalendars = append(userCalendars, userCalendar)</span>
        }

        <span class="cov8" title="1">slog.Info(common.LogUserCalendarList + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessListUserCalendars,
                Data:    userCalendars,
        })</span>
}

// GetByUser récupère toutes les liaisons user calendar pour un utilisateur spécifique (admin)
func (UserCalendarStruct) GetByUser(c *gin.Context) <span class="cov0" title="0">{
        slog.Info(common.LogUserCalendarList)
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">userID := userData.UserID

        rows, err := common.DB.Query(`
                SELECT uc.user_calendar_id, uc.user_id, uc.calendar_id, uc.created_at, uc.updated_at, uc.deleted_at,
                       c.title, c.description
                FROM user_calendar uc
                INNER JOIN calendar c ON uc.calendar_id = c.calendar_id
                WHERE uc.user_id = ? AND uc.deleted_at IS NULL AND c.deleted_at IS NULL
                ORDER BY uc.created_at DESC
        `, userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(common.LogUserCalendarList + " - erreur lors de la récupération des liaisons : " + err.Error())
                c.JSON(http.StatusInternalServerError, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrTransactionStart,
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var userCalendars []common.UserCalendarWithDetails
        for rows.Next() </span><span class="cov0" title="0">{
                var userCalendar common.UserCalendarWithDetails
                err := rows.Scan(
                        &amp;userCalendar.UserCalendarID,
                        &amp;userCalendar.UserID,
                        &amp;userCalendar.CalendarID,
                        &amp;userCalendar.CreatedAt,
                        &amp;userCalendar.UpdatedAt,
                        &amp;userCalendar.DeletedAt,
                        &amp;userCalendar.Title,
                        &amp;userCalendar.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error(common.LogUserCalendarList + " - erreur lors de la lecture des données : " + err.Error())
                        c.JSON(http.StatusInternalServerError, common.JSONResponse{
                                Success: false,
                                Error:   common.ErrTransactionStart,
                        })
                        return
                }</span>
                <span class="cov0" title="0">userCalendars = append(userCalendars, userCalendar)</span>
        }

        <span class="cov0" title="0">slog.Info(common.LogUserCalendarList + " - succès")
        c.JSON(http.StatusOK, common.JSONResponse{
                Success: true,
                Message: common.MsgSuccessListUserCalendars,
                Data:    userCalendars,
        })</span>
}

// checkUserAccess vérifie que l'utilisateur authentifié correspond au user_id de l'URL
func checkUserAccess(c *gin.Context) (int, bool) <span class="cov8" title="1">{
        userData, ok := common.GetUserFromContext(c)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">authUserID := userData.UserID

        userIDParam := c.Param("user_id")
        if userIDParam == "" </span><span class="cov0" title="0">{
                slog.Error("[user_calendar][Access] user_id manquant dans l'URL")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidUserID,
                })
                return 0, false
        }</span>
        <span class="cov8" title="1">userIDFromURL, err := strconv.Atoi(userIDParam)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("[user_calendar][Access] user_id invalide dans l'URL")
                c.JSON(http.StatusBadRequest, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrInvalidUserID,
                })
                return 0, false
        }</span>

        // Vérifier si l'utilisateur authentifié est admin
        <span class="cov8" title="1">roles, err := session.GetUserRoles(authUserID)
        if err == nil </span><span class="cov8" title="1">{
                isAdmin := false
                for _, r := range roles </span><span class="cov8" title="1">{
                        if r.Name == "admin" </span><span class="cov8" title="1">{
                                isAdmin = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if isAdmin </span><span class="cov8" title="1">{
                        // Un admin ne peut pas cibler un autre admin
                        targetRoles, err := session.GetUserRoles(userIDFromURL)
                        if err == nil </span><span class="cov8" title="1">{
                                for _, r := range targetRoles </span><span class="cov8" title="1">{
                                        if r.Name == "admin" </span><span class="cov8" title="1">{
                                                slog.Error("[user_calendar][Access] Tentative d'action admin sur un autre admin interdite")
                                                c.JSON(http.StatusForbidden, common.JSONResponse{
                                                        Success: false,
                                                        Error:   common.ErrInsufficientPermissions,
                                                })
                                                return 0, false
                                        }</span>
                                }
                        }
                        // Admin autorisé
                        <span class="cov8" title="1">return userIDFromURL, true</span>
                }
        }

        // Sinon, accès seulement à soi-même
        <span class="cov0" title="0">if authUserID != userIDFromURL </span><span class="cov0" title="0">{
                slog.Error("[user_calendar][Access] " + common.LogUserCalendarUnauthorizedAccess)
                c.JSON(http.StatusForbidden, common.JSONResponse{
                        Success: false,
                        Error:   common.ErrNoAccessToCalendar,
                })
                return 0, false
        }</span>
        <span class="cov0" title="0">return userIDFromURL, true</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package testutils

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "fmt"
        mathrand "math/rand"
        "net/http"
        "os"
        "strconv"
        "time"

        "go-averroes/internal/calendar"
        "go-averroes/internal/calendar_event"
        "go-averroes/internal/common"
        "go-averroes/internal/middleware"
        "go-averroes/internal/role"
        "go-averroes/internal/session"
        "go-averroes/internal/user"
        "go-averroes/internal/user_calendar"

        "github.com/gin-gonic/gin"
        _ "github.com/go-sql-driver/mysql" // Driver MySQL
        "golang.org/x/crypto/bcrypt"
)

func CreateTestRouter() *gin.Engine <span class="cov0" title="0">{
        gin.SetMode(gin.TestMode)
        router := gin.New()

        // Health check endpoint (public)
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":  "healthy",
                        "service": "GoLendar API",
                })
        }</span>)

        // ===== ROUTES D'AUTHENTIFICATION (publiques) =====
        <span class="cov0" title="0">authGroup := router.Group("/auth")
        </span><span class="cov0" title="0">{
                authGroup.POST("/login", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.Login(c) }</span>)
                <span class="cov0" title="0">authGroup.POST("/refresh", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.RefreshToken(c) }</span>)
        }

        // ===== ROUTES D'AUTHENTIFICATION (protégées) =====
        <span class="cov0" title="0">authProtectedGroup := router.Group("/auth")
        authProtectedGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                authProtectedGroup.POST("/logout", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.Logout(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.GET("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.GetAuthMe(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.GET("/sessions", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.GetUserSessions(c) }</span>)
                <span class="cov0" title="0">authProtectedGroup.DELETE("/sessions/:session_id", func(c *gin.Context) </span><span class="cov0" title="0">{ session.Session.DeleteSession(c) }</span>)
        }

        // ===== ROUTES DE GESTION DES UTILISATEURS =====
        <span class="cov0" title="0">userGroup := router.Group("/user")
        </span><span class="cov0" title="0">{
                // Création d'utilisateur (public - inscription)
                userGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Add(c) }</span>)

                // Routes protégées par authentification
                <span class="cov0" title="0">userProtectedGroup := userGroup.Group("")
                userProtectedGroup.Use(middleware.AuthMiddleware())
                </span><span class="cov0" title="0">{
                        // L'utilisateur peut accéder à ses propres données
                        userProtectedGroup.GET("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Get(c) }</span>)
                        <span class="cov0" title="0">userProtectedGroup.PUT("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Update(c) }</span>)
                        <span class="cov0" title="0">userProtectedGroup.DELETE("/me", func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Delete(c) }</span>)
                }

                // Routes admin pour gérer tous les utilisateurs
                <span class="cov0" title="0">userAdminGroup := userGroup.Group("")
                userAdminGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
                </span><span class="cov0" title="0">{
                        userAdminGroup.GET("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Get(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.PUT("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Update(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.DELETE("/:user_id", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.Delete(c) }</span>)
                        <span class="cov0" title="0">userAdminGroup.GET("/:user_id/with-roles", middleware.UserExistsMiddleware("user_id"), func(c *gin.Context) </span><span class="cov0" title="0">{ user.User.GetUserWithRoles(c) }</span>)
                }
        }

        // ===== ROUTES DE GESTION DES RÔLES (admin uniquement) =====
        <span class="cov0" title="0">roleGroup := router.Group("/roles")
        roleGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
        </span><span class="cov0" title="0">{
                roleGroup.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.ListRoles(c) }</span>)
                <span class="cov0" title="0">roleGroup.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.GetRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.CreateRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.PUT("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.UpdateRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.DELETE("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.DeleteRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("/assign", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.AssignRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.POST("/revoke", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.RevokeRole(c) }</span>)
                <span class="cov0" title="0">roleGroup.GET("/user/:user_id", func(c *gin.Context) </span><span class="cov0" title="0">{ role.Role.GetUserRoles(c) }</span>)
        }

        // ===== ROUTES DE GESTION DES LIAISONS USER-CALENDAR (admin uniquement) =====
        <span class="cov0" title="0">userCalendarGroup := router.Group("/user-calendar")
        userCalendarGroup.Use(middleware.AuthMiddleware(), middleware.AdminMiddleware())
        </span><span class="cov0" title="0">{
                userCalendarGroup.GET("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Get(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.GET("/:user_id",
                        middleware.UserExistsMiddleware("user_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.List(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.POST("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Add(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.PUT("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Update(c) }</span>,
                )
                <span class="cov0" title="0">userCalendarGroup.DELETE("/:user_id/:calendar_id",
                        middleware.UserExistsMiddleware("user_id"),
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ user_calendar.UserCalendar.Delete(c) }</span>,
                )
        }

        // ===== ROUTES DE GESTION DES CALENDRERS =====
        <span class="cov0" title="0">calendarGroup := router.Group("/calendar")
        calendarGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // L'utilisateur peut créer des calendriers
                calendarGroup.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Add(c) }</span>)

                // L'utilisateur peut accéder aux calendriers auxquels il a accès
                <span class="cov0" title="0">calendarGroup.GET("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Get(c) }</span>,
                )
                <span class="cov0" title="0">calendarGroup.PUT("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Update(c) }</span>,
                )
                <span class="cov0" title="0">calendarGroup.DELETE("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar.Calendar.Delete(c) }</span>,
                )
        }

        // ===== ROUTES DE GESTION DES ÉVÉNEMENTS =====
        <span class="cov0" title="0">calendarEventGroup := router.Group("/calendar-event")
        calendarEventGroup.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // Toutes les routes d'événements nécessitent l'accès au calendrier
                calendarEventGroup.GET("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Get(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/month/:year/:month",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByMonth(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/week/:year/:week",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByWeek(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.GET("/:calendar_id/day/:year/:month/:day",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.ListByDay(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.POST("/:calendar_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Add(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.PUT("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Update(c) }</span>,
                )
                <span class="cov0" title="0">calendarEventGroup.DELETE("/:calendar_id/:event_id",
                        middleware.CalendarExistsMiddleware("calendar_id"),
                        middleware.UserCanAccessCalendarMiddleware(),
                        middleware.EventExistsMiddleware("event_id"),
                        func(c *gin.Context) </span><span class="cov0" title="0">{ calendar_event.CalendarEvent.Delete(c) }</span>,
                )
        }

        <span class="cov0" title="0">return router</span>
}

// getEnv retourne la valeur d'une variable d'environnement ou une valeur par défaut si elle n'est pas définie.
func getEnv(key, defaultVal string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

// InitTestDB initialise la base de données pour les tests
// Utilise les variables d'environnement avec des valeurs par défaut pour les tests
func InitTestDB() error <span class="cov0" title="0">{
        // Configuration de test avec variables d'environnement
        testConfig := common.DBConfig{
                User:     getEnv("TEST_DB_USER", "root"),
                Password: getEnv("TEST_DB_PASSWORD", "password"),
                Host:     getEnv("TEST_DB_HOST", "localhost"),
                Port:     3306,                               // Port par défaut MySQL
                Name:     getEnv("TEST_DB_NAME", "calendar"), // Base de données de test séparée
        }

        return common.InitDB(testConfig)
}</span>

// InitTestDBWithConfig initialise la base de données avec une configuration personnalisée
func InitTestDBWithConfig(config common.DBConfig) error <span class="cov0" title="0">{
        return common.InitDB(config)
}</span>

// CleanupTestDB ferme la connexion à la base de données de test
func CleanupTestDB() error <span class="cov0" title="0">{
        PurgeAllTestUsers()
        if common.DB != nil </span><span class="cov0" title="0">{
                return common.DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetupTestEnvironment configure l'environnement de test complet
func SetupTestEnvironment() error <span class="cov0" title="0">{
        // Initialiser la base de données de test
        if err := InitTestDB(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur lors de l'initialisation de la base de données de test: %v", err)
        }</span>

        // Ici on pourrait ajouter d'autres initialisations (logger, etc.)
        <span class="cov0" title="0">return nil</span>
}

// TeardownTestEnvironment nettoie l'environnement de test
func TeardownTestEnvironment() error <span class="cov0" title="0">{
        // Fermer la connexion à la base de données
        if err := CleanupTestDB(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur lors de la fermeture de la base de données de test: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GenerateUniqueEmail génère un email unique avec des lettres aléatoires
// La longueur totale de l'email ne dépasse pas 320 caractères
func GenerateUniqueEmail(baseName string) string <span class="cov0" title="0">{
        // Constantes pour la génération
        const (
                domain    = "@test.example.com"
                separator = "."
                maxLength = 320
                randomLen = 8 // Longueur de la partie aléatoire
        )

        // Calculer la longueur maximale disponible pour baseName
        maxBaseNameLength := maxLength - len(domain) - len(separator) - randomLen

        // Tronquer baseName si nécessaire
        if len(baseName) &gt; maxBaseNameLength </span><span class="cov0" title="0">{
                baseName = baseName[:maxBaseNameLength]
        }</span>

        // Générer des lettres aléatoires
        <span class="cov0" title="0">randomPart := generateRandomLetters(randomLen)

        // Construire l'email
        email := baseName + separator + randomPart + domain

        // Vérification de sécurité (ne devrait jamais dépasser 320)
        if len(email) &gt; maxLength </span><span class="cov0" title="0">{
                // En cas de dépassement, tronquer davantage
                excess := len(email) - maxLength
                if len(baseName) &gt; excess </span><span class="cov0" title="0">{
                        baseName = baseName[:len(baseName)-excess]
                }</span>
                <span class="cov0" title="0">email = baseName + separator + randomPart + domain</span>
        }

        <span class="cov0" title="0">return email</span>
}

// generateRandomLetters génère une chaîne de lettres aléatoires
func generateRandomLetters(length int) string <span class="cov0" title="0">{
        const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        result := make([]byte, length)
        for i := range result </span><span class="cov0" title="0">{
                result[i] = letters[mathrand.Intn(len(letters))]
        }</span>
        <span class="cov0" title="0">return string(result)</span>
}

// Itoa convertit un int en string
func Itoa(i int) string <span class="cov0" title="0">{
        return strconv.Itoa(i)
}</span>

// Purge toutes les données liées aux utilisateurs de test (user, user_roles, user_session, user_password, user_calendar)
func PurgeAllTestUsers() <span class="cov0" title="0">{
        if common.DB == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">common.DB.Exec("SET FOREIGN_KEY_CHECKS=0;")
        common.DB.Exec("TRUNCATE TABLE calendar_event")
        common.DB.Exec("TRUNCATE TABLE event")
        common.DB.Exec("TRUNCATE TABLE user_calendar")
        common.DB.Exec("TRUNCATE TABLE calendar")
        common.DB.Exec("TRUNCATE TABLE user_roles")
        common.DB.Exec("TRUNCATE TABLE user_session")
        common.DB.Exec("TRUNCATE TABLE user_password")
        common.DB.Exec("TRUNCATE TABLE user")
        common.DB.Exec("TRUNCATE TABLE roles")
        common.DB.Exec("SET FOREIGN_KEY_CHECKS=1;")</span>
}

// AuthenticatedUser représente un utilisateur authentifié avec ses informations de session
type AuthenticatedUser struct {
        User         common.User
        Password     string
        SessionToken string
        RefreshToken string
        ExpiresAt    time.Time
        Roles        []common.Role
        Calendar     *common.Calendar
        Event        *common.Event
}

// GenerateAuthenticatedAdmin génère un admin avec option d'authentification
// Si authenticated = true, crée une session active d'une durée de 1 jour
// Si authenticated = false, crée seulement l'utilisateur admin sans session
// Si saveToDB = true, enregistre l'utilisateur et la session en base de données
// Si saveToDB = false, crée seulement l'objet en mémoire sans persistance
// Si hasCalendar = true, crée un calendrier associé à l'utilisateur
// Si hasEvent = true, crée un événement dans le calendrier (nécessite hasCalendar = true)
func GenerateAuthenticatedAdmin(authenticated, saveToDB, hasCalendar, hasEvent bool) (*AuthenticatedUser, error) <span class="cov0" title="0">{
        // Générer un email unique
        email := GenerateUniqueEmail("admin")
        password := "AdminPassword123!"

        var admin *common.User
        var roles []common.Role
        var sessionToken, refreshToken string
        var expiresAt time.Time
        var calendar *common.Calendar
        var event *common.Event
        var err error

        if saveToDB </span><span class="cov0" title="0">{
                // Créer l'utilisateur admin en base
                admin, err = createUserWithPassword("Admin", "User", email, password)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la création de l'admin: %v", err)
                }</span>

                // Créer le rôle admin s'il n'existe pas
                <span class="cov0" title="0">adminRoleID, err := ensureAdminRoleExists()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la création du rôle admin: %v", err)
                }</span>

                // Assigner le rôle admin à l'utilisateur
                <span class="cov0" title="0">err = assignRoleToUser(admin.UserID, adminRoleID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de l'attribution du rôle admin: %v", err)
                }</span>

                // Récupérer les rôles de l'utilisateur
                <span class="cov0" title="0">roles, err = session.GetUserRoles(admin.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la récupération des rôles: %v", err)
                }</span>

                // Si authentifié, créer une session active d'une durée de 1 jour
                <span class="cov0" title="0">if authenticated </span><span class="cov0" title="0">{
                        sessionToken, refreshToken, expiresAt, err = CreateUserSession(admin.UserID, 24*time.Hour)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création de la session: %v", err)
                        }</span>
                }

                // Créer un calendrier si demandé
                <span class="cov0" title="0">if hasCalendar </span><span class="cov0" title="0">{
                        calendarID, err := CreateCalendarForUser(admin.UserID, "Calendrier Admin", "Calendrier de test pour admin")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création du calendrier: %v", err)
                        }</span>

                        // Récupérer les informations du calendrier créé
                        <span class="cov0" title="0">calendar = &amp;common.Calendar{}
                        err = common.DB.QueryRow(`
                                SELECT calendar_id, title, description, created_at, updated_at, deleted_at 
                                FROM calendar 
                                WHERE calendar_id = ?
                        `, calendarID).Scan(&amp;calendar.CalendarID, &amp;calendar.Title, &amp;calendar.Description, &amp;calendar.CreatedAt, &amp;calendar.UpdatedAt, &amp;calendar.DeletedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la récupération du calendrier: %v", err)
                        }</span>
                }

                // Créer un événement si demandé (nécessite un calendrier)
                <span class="cov0" title="0">if hasEvent &amp;&amp; hasCalendar </span><span class="cov0" title="0">{
                        eventID, err := createEventForUser(admin.UserID, "Événement Admin", "Événement de test pour admin")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création de l'événement: %v", err)
                        }</span>

                        // Récupérer les informations de l'événement créé
                        <span class="cov0" title="0">event = &amp;common.Event{}
                        err = common.DB.QueryRow(`
                                SELECT event_id, title, description, start, duration, canceled, created_at, updated_at, deleted_at 
                                FROM event 
                                WHERE event_id = ?
                        `, eventID).Scan(&amp;event.EventID, &amp;event.Title, &amp;event.Description, &amp;event.Start, &amp;event.Duration, &amp;event.Canceled, &amp;event.CreatedAt, &amp;event.UpdatedAt, &amp;event.DeletedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la récupération de l'événement: %v", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Créer l'utilisateur admin en mémoire seulement
                admin = &amp;common.User{
                        UserID:    1, // ID fictif pour les tests
                        Lastname:  "Admin",
                        Firstname: "User",
                        Email:     email,
                        CreatedAt: time.Now(),
                        UpdatedAt: nil,
                        DeletedAt: nil,
                }

                // Créer le rôle admin en mémoire
                adminRole := common.Role{
                        RoleID:      1,
                        Name:        "admin",
                        Description: common.StringPtr("Administrateur avec tous les droits"),
                        CreatedAt:   time.Now(),
                        UpdatedAt:   nil,
                        DeletedAt:   nil,
                }
                roles = []common.Role{adminRole}

                // Si authentifié, générer des tokens en mémoire
                if authenticated </span><span class="cov0" title="0">{
                        sessionToken, err = generateToken()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la génération du session token: %v", err)
                        }</span>

                        <span class="cov0" title="0">refreshToken, err = generateToken()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la génération du refresh token: %v", err)
                        }</span>

                        <span class="cov0" title="0">expiresAt = time.Now().Add(24 * time.Hour)</span>
                }

                // Créer un calendrier en mémoire si demandé
                <span class="cov0" title="0">if hasCalendar </span><span class="cov0" title="0">{
                        calendar = &amp;common.Calendar{
                                CalendarID:  1,
                                Title:       "Calendrier Admin",
                                Description: common.StringPtr("Calendrier de test pour admin"),
                                CreatedAt:   time.Now(),
                                UpdatedAt:   nil,
                                DeletedAt:   nil,
                        }
                }</span>

                // Créer un événement en mémoire si demandé
                <span class="cov0" title="0">if hasEvent &amp;&amp; hasCalendar </span><span class="cov0" title="0">{
                        event = &amp;common.Event{
                                EventID:     1,
                                Title:       "Événement Admin",
                                Description: common.StringPtr("Événement de test pour admin"),
                                Start:       time.Now().Add(1 * time.Hour),
                                Duration:    60,
                                Canceled:    false,
                                CreatedAt:   time.Now(),
                                UpdatedAt:   nil,
                                DeletedAt:   nil,
                        }
                }</span>
        }

        <span class="cov0" title="0">return &amp;AuthenticatedUser{
                User:         *admin,
                Password:     password,
                SessionToken: sessionToken,
                RefreshToken: refreshToken,
                ExpiresAt:    expiresAt,
                Roles:        roles,
                Calendar:     calendar,
                Event:        event,
        }, nil</span>
}

// GenerateAuthenticatedUser génère un utilisateur normal avec option d'authentification
// Si authenticated = true, crée une session active d'une durée de 1 jour
// Si authenticated = false, crée seulement l'utilisateur normal sans session
// Si saveToDB = true, enregistre l'utilisateur et la session en base de données
// Si saveToDB = false, crée seulement l'objet en mémoire sans persistance
// Si hasCalendar = true, crée un calendrier associé à l'utilisateur
// Si hasEvent = true, crée un événement dans le calendrier (nécessite hasCalendar = true)
func GenerateAuthenticatedUser(authenticated, saveToDB, hasCalendar, hasEvent bool) (*AuthenticatedUser, error) <span class="cov0" title="0">{
        // Générer un email unique
        email := GenerateUniqueEmail("user")
        password := "UserPassword123!"

        var user *common.User
        var roles []common.Role
        var sessionToken, refreshToken string
        var expiresAt time.Time
        var calendar *common.Calendar
        var event *common.Event
        var err error

        if saveToDB </span><span class="cov0" title="0">{
                // Créer l'utilisateur normal en base
                user, err = createUserWithPassword("Normal", "User", email, password)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la création de l'utilisateur: %v", err)
                }</span>

                // Récupérer les rôles de l'utilisateur (normalement vide pour un utilisateur normal)
                <span class="cov0" title="0">roles, err = session.GetUserRoles(user.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la récupération des rôles: %v", err)
                }</span>

                // Si authentifié, créer une session active d'une durée de 1 jour
                <span class="cov0" title="0">if authenticated </span><span class="cov0" title="0">{
                        sessionToken, refreshToken, expiresAt, err = CreateUserSession(user.UserID, 24*time.Hour)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création de la session: %v", err)
                        }</span>
                }

                // Créer un calendrier si demandé
                <span class="cov0" title="0">if hasCalendar </span><span class="cov0" title="0">{
                        calendarID, err := CreateCalendarForUser(user.UserID, "Calendrier Utilisateur", "Calendrier de test pour utilisateur")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création du calendrier: %v", err)
                        }</span>

                        // Récupérer les informations du calendrier créé
                        <span class="cov0" title="0">calendar = &amp;common.Calendar{}
                        err = common.DB.QueryRow(`
                                SELECT calendar_id, title, description, created_at, updated_at, deleted_at 
                                FROM calendar 
                                WHERE calendar_id = ?
                        `, calendarID).Scan(&amp;calendar.CalendarID, &amp;calendar.Title, &amp;calendar.Description, &amp;calendar.CreatedAt, &amp;calendar.UpdatedAt, &amp;calendar.DeletedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la récupération du calendrier: %v", err)
                        }</span>
                }

                // Créer un événement si demandé (nécessite un calendrier)
                <span class="cov0" title="0">if hasEvent &amp;&amp; hasCalendar </span><span class="cov0" title="0">{
                        eventID, err := createEventForUser(user.UserID, "Événement Utilisateur", "Événement de test pour utilisateur")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la création de l'événement: %v", err)
                        }</span>

                        // Récupérer les informations de l'événement créé
                        <span class="cov0" title="0">event = &amp;common.Event{}
                        err = common.DB.QueryRow(`
                                SELECT event_id, title, description, start, duration, canceled, created_at, updated_at, deleted_at 
                                FROM event 
                                WHERE event_id = ?
                        `, eventID).Scan(&amp;event.EventID, &amp;event.Title, &amp;event.Description, &amp;event.Start, &amp;event.Duration, &amp;event.Canceled, &amp;event.CreatedAt, &amp;event.UpdatedAt, &amp;event.DeletedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la récupération de l'événement: %v", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Créer l'utilisateur normal en mémoire seulement
                user = &amp;common.User{
                        UserID:    2, // ID fictif pour les tests
                        Lastname:  "Normal",
                        Firstname: "User",
                        Email:     email,
                        CreatedAt: time.Now(),
                        UpdatedAt: nil,
                        DeletedAt: nil,
                }

                // Utilisateur normal sans rôles
                roles = []common.Role{}

                // Si authentifié, générer des tokens en mémoire
                if authenticated </span><span class="cov0" title="0">{
                        sessionToken, err = generateToken()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la génération du session token: %v", err)
                        }</span>

                        <span class="cov0" title="0">refreshToken, err = generateToken()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la génération du refresh token: %v", err)
                        }</span>

                        <span class="cov0" title="0">expiresAt = time.Now().Add(24 * time.Hour)</span>
                }

                // Créer un calendrier en mémoire si demandé
                <span class="cov0" title="0">if hasCalendar </span><span class="cov0" title="0">{
                        calendar = &amp;common.Calendar{
                                CalendarID:  2,
                                Title:       "Calendrier Utilisateur",
                                Description: common.StringPtr("Calendrier de test pour utilisateur"),
                                CreatedAt:   time.Now(),
                                UpdatedAt:   nil,
                                DeletedAt:   nil,
                        }
                }</span>

                // Créer un événement en mémoire si demandé
                <span class="cov0" title="0">if hasEvent &amp;&amp; hasCalendar </span><span class="cov0" title="0">{
                        event = &amp;common.Event{
                                EventID:     2,
                                Title:       "Événement Utilisateur",
                                Description: common.StringPtr("Événement de test pour utilisateur"),
                                Start:       time.Now().Add(1 * time.Hour),
                                Duration:    60,
                                Canceled:    false,
                                CreatedAt:   time.Now(),
                                UpdatedAt:   nil,
                                DeletedAt:   nil,
                        }
                }</span>
        }

        <span class="cov0" title="0">return &amp;AuthenticatedUser{
                User:         *user,
                Password:     password,
                SessionToken: sessionToken,
                RefreshToken: refreshToken,
                ExpiresAt:    expiresAt,
                Roles:        roles,
                Calendar:     calendar,
                Event:        event,
        }, nil</span>
}

// Fonctions utilitaires privées

// createUserWithPassword crée un utilisateur avec un mot de passe hashé
func createUserWithPassword(lastname, firstname, email, password string) (*common.User, error) <span class="cov0" title="0">{
        // Hasher le mot de passe
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors du hashage du mot de passe: %v", err)
        }</span>

        <span class="cov0" title="0">tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors du démarrage de la transaction: %v", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Créer l'utilisateur
        result, err := tx.Exec(`
                INSERT INTO user (lastname, firstname, email, created_at) 
                VALUES (?, ?, ?, NOW())
        `, lastname, firstname, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors de la création de l'utilisateur: %v", err)
        }</span>

        <span class="cov0" title="0">userID, _ := result.LastInsertId()

        // Créer le mot de passe
        _, err = tx.Exec(`
                INSERT INTO user_password (user_id, password_hash, created_at) 
                VALUES (?, ?, NOW())
        `, userID, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors de la création du mot de passe: %v", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors du commit de la transaction: %v", err)
        }</span>

        // Récupérer l'utilisateur créé
        <span class="cov0" title="0">var user common.User
        err = common.DB.QueryRow(`
                SELECT user_id, lastname, firstname, email, created_at, updated_at, deleted_at
                FROM user WHERE user_id = ?
        `, userID).Scan(
                &amp;user.UserID,
                &amp;user.Lastname,
                &amp;user.Firstname,
                &amp;user.Email,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
                &amp;user.DeletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors de la récupération de l'utilisateur: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// ensureAdminRoleExists s'assure que le rôle admin existe et retourne son ID
func ensureAdminRoleExists() (int, error) <span class="cov0" title="0">{
        // Vérifier si le rôle admin existe déjà
        var roleID int
        err := common.DB.QueryRow("SELECT role_id FROM roles WHERE name = 'admin' AND deleted_at IS NULL").Scan(&amp;roleID)
        if err == nil </span><span class="cov0" title="0">{
                // Le rôle existe déjà
                return roleID, nil
        }</span>

        <span class="cov0" title="0">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la vérification du rôle admin: %v", err)
        }</span>

        // Le rôle n'existe pas, le créer
        <span class="cov0" title="0">result, err := common.DB.Exec(`
                INSERT INTO roles (name, description, created_at) 
                VALUES ('admin', 'Administrateur avec tous les droits', NOW())
        `)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la création du rôle admin: %v", err)
        }</span>

        <span class="cov0" title="0">newRoleID, _ := result.LastInsertId()
        return int(newRoleID), nil</span>
}

// assignRoleToUser assigne un rôle à un utilisateur
func assignRoleToUser(userID, roleID int) error <span class="cov0" title="0">{
        // Vérifier si l'attribution existe déjà
        var existingID int
        err := common.DB.QueryRow("SELECT user_roles_id FROM user_roles WHERE user_id = ? AND role_id = ? AND deleted_at IS NULL", userID, roleID).Scan(&amp;existingID)
        if err == nil </span><span class="cov0" title="0">{
                // L'attribution existe déjà
                return nil
        }</span>

        <span class="cov0" title="0">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur lors de la vérification de l'attribution de rôle: %v", err)
        }</span>

        // Créer l'attribution
        <span class="cov0" title="0">_, err = common.DB.Exec(`
                INSERT INTO user_roles (user_id, role_id, created_at) 
                VALUES (?, ?, NOW())
        `, userID, roleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur lors de l'attribution du rôle: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateUserSession crée une session pour un utilisateur avec une durée spécifiée
func CreateUserSession(userID int, duration time.Duration) (string, string, time.Time, error) <span class="cov0" title="0">{
        // Générer les tokens
        sessionToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, fmt.Errorf("erreur lors de la génération du session token: %v", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, fmt.Errorf("erreur lors de la génération du refresh token: %v", err)
        }</span>

        // Définir l'expiration
        <span class="cov0" title="0">expiresAt := time.Now().Add(duration)

        // Créer la session en base
        _, err = common.DB.Exec(`
                INSERT INTO user_session (user_id, session_token, refresh_token, expires_at, device_info, ip_address, is_active, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, TRUE, NOW())
        `, userID, sessionToken, refreshToken, expiresAt, "Test Device", "127.0.0.1")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, fmt.Errorf("erreur lors de la création de la session: %v", err)
        }</span>

        <span class="cov0" title="0">return sessionToken, refreshToken, expiresAt, nil</span>
}

// generateToken génère un token aléatoire (copié depuis session.go)
func generateToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// GetStringValue retourne la valeur d'un pointeur string ou "&lt;nil&gt;" si nil
func GetStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return "&lt;nil&gt;"
        }</span>
        <span class="cov0" title="0">return *s</span>
}

// createCalendarForUser crée un calendrier et l'associe à un utilisateur
func CreateCalendarForUser(userID int, title, description string) (int, error) <span class="cov0" title="0">{
        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors du démarrage de la transaction: %v", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Créer le calendrier
        result, err := tx.Exec(`
                INSERT INTO calendar (title, description, created_at) 
                VALUES (?, ?, NOW())
        `, title, description)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la création du calendrier: %v", err)
        }</span>

        <span class="cov0" title="0">calendarID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la récupération de l'ID du calendrier: %v", err)
        }</span>

        // Associer le calendrier à l'utilisateur
        <span class="cov0" title="0">_, err = tx.Exec(`
                INSERT INTO user_calendar (user_id, calendar_id, created_at) 
                VALUES (?, ?, NOW())
        `, userID, calendarID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la création de la liaison user_calendar: %v", err)
        }</span>

        // Valider la transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors du commit de la transaction: %v", err)
        }</span>

        <span class="cov0" title="0">return int(calendarID), nil</span>
}

// createEventForUser crée un événement dans le premier calendrier de l'utilisateur
func createEventForUser(userID int, title, description string) (int, error) <span class="cov0" title="0">{
        // Démarrer une transaction
        tx, err := common.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors du démarrage de la transaction: %v", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Récupérer le premier calendrier de l'utilisateur
        var calendarID int
        err = tx.QueryRow(`
                SELECT uc.calendar_id 
                FROM user_calendar uc
                INNER JOIN calendar c ON uc.calendar_id = c.calendar_id
                WHERE uc.user_id = ? AND uc.deleted_at IS NULL AND c.deleted_at IS NULL
                ORDER BY uc.created_at ASC
                LIMIT 1
        `, userID).Scan(&amp;calendarID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la récupération du calendrier: %v", err)
        }</span>

        // Créer l'événement
        <span class="cov0" title="0">startTime := time.Now().Add(1 * time.Hour) // Événement dans 1 heure
        result, err := tx.Exec(`
                INSERT INTO event (title, description, start, duration, canceled, created_at) 
                VALUES (?, ?, ?, ?, ?, NOW())
        `, title, description, startTime, 60, false) // Durée de 60 minutes
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la création de l'événement: %v", err)
        }</span>

        <span class="cov0" title="0">eventID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la récupération de l'ID de l'événement: %v", err)
        }</span>

        // Associer l'événement au calendrier
        <span class="cov0" title="0">_, err = tx.Exec(`
                INSERT INTO calendar_event (calendar_id, event_id, created_at) 
                VALUES (?, ?, NOW())
        `, calendarID, eventID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors de la création de la liaison calendar_event: %v", err)
        }</span>

        // Valider la transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("erreur lors du commit de la transaction: %v", err)
        }</span>

        <span class="cov0" title="0">return int(eventID), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
